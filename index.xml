<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>A blog about a computer made from relays on Relay Computer</title><link>https://relaycomputer.co.uk/</link><description>Recent content in A blog about a computer made from relays on Relay Computer</description><generator>Hugo</generator><language>en-gb</language><lastBuildDate>Mon, 05 Dec 2022 06:00:00 +0000</lastBuildDate><atom:link href="https://relaycomputer.co.uk/index.xml" rel="self" type="application/rss+xml"/><item><title>Controller Design: MOV8, MOV16 &amp; MISC Instructions</title><link>https://relaycomputer.co.uk/posts/2022/12/controller-mov8-mov16-misc-design/</link><pubDate>Mon, 05 Dec 2022 06:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/12/controller-mov8-mov16-misc-design/</guid><description>Way back in 2019 I discussed how you can’t ‘half design a PCB’ and that, as a result, my controller cards already have all the required functionality laid down … I just haven’t explained how those ‘missing’ bits of functionality work in this blog yet.
To ensure I was ‘playing fair’ when constructing the controller I only soldered in the relays for the instructions I’d explained in this blog so far. Well, in my Relay Clock Series you may have noticed in the final episode I decided to solder the remaining relays in on the lower controller card meaning … the MOV8, MOV16 and MISC instruction classes are now complete and pretty much raring to go … which means I should probably get on with explaining them.</description></item><item><title>Assembling an assembler - token scanning</title><link>https://relaycomputer.co.uk/posts/2022/11/assembly-part-2/</link><pubDate>Sun, 27 Nov 2022 10:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/11/assembly-part-2/</guid><description>In the last episode of this mini-series I explained about how an assembler’s job is effectively to convert a program written in a language a human programmer can understand (assembly language in this case) into something which a computer can understand. So as an example, the assembler will take something like this …
start: ldi a,1 ; initial setup A = 1 ldi b,0 ; B = 0 loop: mov c,b ; slide B -> C mov b,a ; A -> B add ; and add together done: bcs done ; infinite loop if overflowed jmp loop ; otherwise have another go … and turn it in to something like this …</description></item><item><title>Tick Tock</title><link>https://relaycomputer.co.uk/posts/2022/11/tick-tock/</link><pubDate>Sun, 20 Nov 2022 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/11/tick-tock/</guid><description>Well, what a journey that’s been then … I started work on a clock for my relay computer back in May 2020 and today (20th Nov 2022) this post marks the end of it. Needless to say that global pandemic got in the way a bit and hampered progress but I also, well, kind of fell out of love with my relay computer for a bit.
Like most of my hobbies I can blow ‘hot and cold’ but given I also set myself the challenge of closely detailing progress in a series of videos (all 16 of them) it was leaning me towards the ‘cold’ rather than the ‘hot’. Anyho, we’re here now and the computer finally has its clock and all card bays of the computer now have something in them.</description></item><item><title>Back to Backplanes</title><link>https://relaycomputer.co.uk/posts/2022/11/back-to-backplanes/</link><pubDate>Sat, 05 Nov 2022 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/11/back-to-backplanes/</guid><description>Quite a while ago I decided to give up on the tedious wire wrap technique for building my cards. Although it was certainly more authentic and in-keeping with my computer’s theme it was massively time consuming for me and was ultimately putting me off making progress on construction.
Another problem with my previous construction methods was creating monstrosities like this:
This is the ‘W’ backplane connector which connects five of the ‘W’ type cards together … and its as precarious as it looks and over time I’ve found the ribbon cable on the back of these backplanes are getting a bit temperamental. If left well alone they’re fine but any knocks or pokes and whole lines can become disconnected. To solve this I made my own PCB for the Y backplane removing the need for the ribbon cable:</description></item><item><title>Assembling an assembler - overview</title><link>https://relaycomputer.co.uk/posts/2022/05/assembly-part-1/</link><pubDate>Sat, 14 May 2022 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/05/assembly-part-1/</guid><description>To make my relay computer do something interesting (or anything at all) it needs a list of instructions held in memory. Each instruction consists of an 8-bit value called an opcode (portmanteau of operation and code) optionally followed by one or two further 8-bit values (usually referencing a location in memory). The computer will work through them one at a time doing whatever operation that opcode represents. Here’s an example program:</description></item><item><title>Intermission</title><link>https://relaycomputer.co.uk/posts/2022/05/intermission/</link><pubDate>Mon, 02 May 2022 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2022/05/intermission/</guid><description>So, is fair to say that things have been a bit quiet around here of late … and if you’ve been following my YouTube channel I do hope you haven’t been holding your breath for the next episode of ‘making a relay computer clock’ as the last episode came out just over a year ago!
What’s been going on then? Well first of all I’m fine (and actually writing this on one of the lazier days of a holiday in Crete … so I’m especially ‘fine’ and relaxed) but like most people the Covid lockdown has had its impact. My day job was always quite busy but over the last couple of years it’s been particularly busy and then combined with not having holidays to recharge I’d frankly lost all interest (and time) for my hobbies. Normality ultimately returns though (even if it’s a ’new normal’) and so does my appetite for hobbies.</description></item><item><title>2020 Update</title><link>https://relaycomputer.co.uk/posts/2020/02/twenty-twenty-update/</link><pubDate>Sat, 01 Feb 2020 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2020/02/twenty-twenty-update/</guid><description>As the clock struck midnight at the very end of 2019 I decided, over a glass of something sparkling, that I’d set myself a challenge to put out a series of six YouTube videos within the space of one month. This, I thought, seemed timely as I’ve now got my relay computer to the point where it can perform branching operations and therefore run more interesting programs.
Well, somehow I managed to stick to my challenge and although it turned out to be a gruelling schedule below are the six videos I published. If you’ve been following me on YouTube you’ll no doubt have seen these by now but just for completness I’ve repeated them below.</description></item><item><title>Decoder Construction</title><link>https://relaycomputer.co.uk/posts/2020/01/decoder-construction/</link><pubDate>Sun, 05 Jan 2020 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2020/01/decoder-construction/</guid><description>In my last post I covered off the full design for the decoder card so all that remains is to get it soldered up and tested. As before I’ve put a video together which covers the highlights:
As you can see towards the end of the video that’s the basics of branching complete and finally my computer is capable of running more complicated programs that have loops and decision making points in them. As reaching this point has coincided nicely with the start of a new decade I’ll now pause construction for a moment whilst I create a series of ‘2020 update’ videos. In these videos I’ll cover off:</description></item><item><title>Decoder Design: Schematic &amp; PCBs</title><link>https://relaycomputer.co.uk/posts/2019/12/decoder-design-pcb/</link><pubDate>Sun, 22 Dec 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/12/decoder-design-pcb/</guid><description>I’ve almost got everything I need now to get my relay computer to do branching. The hard work of designing and constructing the sequencer and controller units is complete and both units can perform a GOTO operation. The only problem now is the decoder card doesn’t understand what a GOTO instruction looks like and so can’t tell the controller unit to perform a GOTO. That’s easily fixed though as the decoder is one of the simplest cards in my computer.</description></item><item><title>Controller Construction</title><link>https://relaycomputer.co.uk/posts/2019/12/controller-construction/</link><pubDate>Sat, 21 Dec 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/12/controller-construction/</guid><description>In my last couple of posts I covered off the full design for the controller unit. As the PCBs have now arrived I can get on with soldering up the cards and giving them a test. As mentioned in my last post, although the controller supports all the instruction classes the computer will eventually use I’m only soldering up the ALU, GOTO, MOV8 and SETAB instructions for now.
Let’s start with the lower card and, as before, I’ve put together a video which covers the highlights:</description></item><item><title>Controller Design: Schematic &amp; PCBs</title><link>https://relaycomputer.co.uk/posts/2019/12/controller-design-pcb/</link><pubDate>Fri, 20 Dec 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/12/controller-design-pcb/</guid><description>In my last couple of posts I finalised the controller schematic designs for the ALU, SETAB, MOV8 and GOTO class of instructions. Now it’s time to bring all those schematics together and design the two controller PCBs. As with the sequencer, the controller is spread over two interconnected cards and I’ll need to decide what’s going on the upper card and what will go on the lower card.
It’s also worth mentioning at this point that the schematics and PCB designs I’m about to share will have some instruction classes laid out that I haven’t covered yet in this blog. This is because you can’t ‘half design’ a PCB. I’ll cover these new instructions in more detail in the future but suffice to say that they’ll definitely be needed. In choosing what will go on which card I follow a similar rule to what I did on the sequencer and go by the number of relays required in each functional group. In the end I’ve gone for putting GOTO and MOV8/MOV16/MISC on the lower card and everything else on the upper card.</description></item><item><title>Controller Design: ALU, MOV8 &amp; SETAB Instructions</title><link>https://relaycomputer.co.uk/posts/2019/12/controller-alu-mov8-setab-design/</link><pubDate>Sat, 07 Dec 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/12/controller-alu-mov8-setab-design/</guid><description>In my last post I covered off the controller design for the GOTO instruction. Being as I’ve decided to implement the controller on a new set of PCB cards I need to transfer over the existing ALU, MOV8 &amp; SETAB instructions to the new controller design. At the relay level nothing really changes so I’ll just quickly recap the timing and implementations here using the new schematic style and then in my next post I can move on to putting the full controller schematic and PCB design together.</description></item><item><title>Controller Design: GOTO Instruction</title><link>https://relaycomputer.co.uk/posts/2019/11/controller-goto-design/</link><pubDate>Sat, 30 Nov 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/11/controller-goto-design/</guid><description>With the sequencer now designed and constructed I’m much closer to getting branching working on my relay computer. The next hurdle is updating the controller cards so that they can fire the appropriate control lines at the right time as directed by the sequencer pulses. As a reminder here’s the GOTO instruction itself:
Branch/Call &amp; 16-bit Load Immediate GOTO 24 1 1 d s c z n x h h h h h h h h l l l l l l l l Branches to a given address if stated condition register flag(s) is set. Address of next instruction can optionally be saved in XY register. M register can also be loaded with 16-bit value (without jump).</description></item><item><title>Sequencer Construction</title><link>https://relaycomputer.co.uk/posts/2019/11/sequencer-construction/</link><pubDate>Wed, 20 Nov 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-construction/</guid><description>In my last couple of posts I covered off the full design for the sequencer unit. With PCBs now safely arrived in the post I can get on with soldering up the cards and giving them a test.
Let’s start with the lower card and, as before, I’ve put together a video which covers the highlights:
Likewise, here’s a video covering the upper card construction which also includes giving the cards a test together and then testing the whole sequencer unit when placed in the computer:</description></item><item><title>Sequencer Design: Schematic &amp; PCBs</title><link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pcb/</link><pubDate>Mon, 11 Nov 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pcb/</guid><description>I’ve got the designs for the 24-cycle FSM and pulse distribution in place so all that’s left for the sequencer is to bring the schematics together and then design the PCBs … and yup, that’s PCBs plural as this is going to be another part of the computer that is complicated enough to need spreading over two interconnected cards. The way I can tell this is a ’two card job’ is purely down to the number of relays I’ve used. In this case the total comes to 60 and if you’re really packing them in (6 rows of 8 relays) you can just about get away with a maximum of 48 per card.</description></item><item><title>Sequencer Design: Pulse Distribution</title><link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pulse-dist/</link><pubDate>Sat, 02 Nov 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pulse-dist/</guid><description>In my last post I extended the 8-cycle FSM (finite state machine) design all the way up to 24-cycles so that we can run longer and more complicated instructions. In this case we’re looking to implement the GOTO instruction so that the computer can perform branching.
As a recap here’s the outputs from the newly designed FSM:
24-cycle FSM Outputs (larger) … and here’s the timing chart that we’re trying to obtain:</description></item><item><title>Sequencer Design: 24-cycle FSM</title><link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-24-cycle-fsm/</link><pubDate>Fri, 01 Nov 2019 03:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-24-cycle-fsm/</guid><description>Recently I’ve been looking at what’s needed to implement branching in my computer (the upcoming GOTO class of instructions). In my last post I covered the timing chart for the GOTO class which is repeated below:
GOTO opcode timing chart (larger) To achieve this timing I’ll need a sequencer that can ‘count’ up to 24 (currently it only goes up to 8). Actually none of this is too difficult as counting beyond 8 more-or-less repeats the same pattern of relays. If you’re not familiar with how the current 8 cycle sequencer works then it’s well worth reading the post on that which goes in to more detail around how the FSM (finite state machine) works.</description></item><item><title>Branching: Opcode Timing</title><link>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</link><pubDate>Sun, 06 Oct 2019 01:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</guid><description>In my last post I covered the design for the GOTO opcode which will enable my relay computer to perform branching, loops and so on. Here’s where I got to last time:
Branch/Call &amp; 16-bit Load Immediate GOTO 24 1 1 d s c z n x h h h h h h h h l l l l l l l l Branches to a given address if stated condition register flag(s) is set. Address of next instruction can optionally be saved in XY register. M register can also be loaded with 16-bit value (without jump).</description></item><item><title>Branching: Opcode Design</title><link>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</link><pubDate>Mon, 23 Sep 2019 01:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</guid><description>There’s been a common theme recently in the comments on my YouTube videos … people are ready to see my relay computer gain the power of branching and become a ‘proper’ computer … and that’s fair enough because that’s the point where the computer can do way more interesting things and run more complicated programs. Originally I was going to add new instructions to the computer in order of complexity but I don’t want to keep you (or I) waiting for the ‘main event’ any longer so it’s time to start designing the most complicated of all instruction classes … the ‘GOTO’.</description></item><item><title>16-bit Register PCB Design</title><link>https://relaycomputer.co.uk/posts/2019/08/16bit-register-pcb-design/</link><pubDate>Fri, 09 Aug 2019 01:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/08/16bit-register-pcb-design/</guid><description>It’s time for the oddly therapeutic part of designing a PCB … laying out the board. In my last post I covered the schematic design and so we now have all the components required for a 16-bit register captured in my design program of choice (EasyEDA) along with how each component is connected to everything else. The next step is to generate a PCB layout from that schematic … and I say ‘generate’ which perhaps makes it sound like it’s a ‘click of a button’ type thing … well, clicking the ‘create PCB’ button results in this:</description></item><item><title>16-bit Register Design</title><link>https://relaycomputer.co.uk/posts/2019/07/16bit-register-design/</link><pubDate>Mon, 15 Jul 2019 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/07/16bit-register-design/</guid><description>In my last couple of posts I’ve been building up to a change of approach in how I’m making the cards in my computer. This is mainly because I can’t face the monotony of hand building the upcoming register cards (which I’ll need three of so it’s triple the procrastination holding me back). The obvious solution to all of this is to create a Printed Circuit Board (PCB) which will cut out most of the trickier soldering and pretty much all the repetitive wirewrap … and that looked like the way to go until I had a go at hand crafting a simplified PCB for the Y backplane and I realised it’s not as easy as it might otherwise appear.</description></item><item><title>Making a PCB</title><link>https://relaycomputer.co.uk/posts/2019/03/making-a-pcb/</link><pubDate>Mon, 04 Mar 2019 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/03/making-a-pcb/</guid><description>After years of using pad/prototyping boards to build my computer I’ve decided to switch things up a bit and have a go at making a custom PCB. The thinking is that it should save me loads of time soldering and wire wrapping which will come in handy as I’ll soon be constructing three fairly-identical register cards and my patience is notoriously short. That said though it probably makes sense that my first PCB should be something a bit simpler. As it happens I do need to construct the Y backplane (which the 5 ‘Y’ type cards connect in to) which is a much simpler design and therefore an excellent ‘first PCB’ candidate.</description></item><item><title>A change of approach</title><link>https://relaycomputer.co.uk/posts/2019/01/change-of-approach/</link><pubDate>Mon, 14 Jan 2019 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/01/change-of-approach/</guid><description>In my last post I touched on how the repetitive nature of making register cards has been putting me off progressing my relay computer. If you’ve followed my blog (over the years) you’ll have witnessed the construction of the general purpose registers A, B, C and D along with the specialised registers in the incrementer and program counter. Each register card follows the same construction pattern: solder down LEDs, solder down relay sockets, solder down wire wrap posts, solder ground and power lines, wire wrap, wire wrap, wire wrap, wire wrap, etc, etc, insert relays in sockets. Tedious, tedious, tedious.</description></item><item><title>Procrastination is the thief of time</title><link>https://relaycomputer.co.uk/posts/2019/01/procrastination-is/</link><pubDate>Sun, 06 Jan 2019 11:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2019/01/procrastination-is/</guid><description>… or so the proverb goes … and it’s fair to say I’ve been procrastinating quite a bit recently.
I typically take a summer break from working on the relay computer so that I can service all the other hobbies I have on the go but also to enjoy the brief warm weather we get here in the UK. Usually come autumn time I’m back building, blogging and making videos but this year ‘summer’ has hung on … through to the end of the year no less … and it’s because I’m intentionally/unintentionally putting off getting started. What’s to blame? Other than my own lack of self control? … it’s those damn registers. Let me try and explain …</description></item><item><title>Auxiliary Control Construction</title><link>https://relaycomputer.co.uk/posts/2018/03/auxiliary-control-construction/</link><pubDate>Tue, 27 Mar 2018 22:07:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/03/auxiliary-control-construction/</guid><description>In my last three posts I covered the design of the auxiliary control unit which will ease entering and inspecting programs in the computer’s memory. With the design ‘in the bag’ it’s time to get constructing although this time we’re not starting with a blank card …
Currently the auxiliary card has the gating relays along the bottom which connect the primary switches to either the address or data bus as required. So far these gating relays have been operated manually but that’s about to change as I add the remaining auxiliary control circuitry which will operate the gating directly. Also on the card are the row of LEDs on the left, card connectors at the top and finally the primary switch connectors on the right. Again, all of these bits will be hooked up shortly as I add the control circuitry. First though let’s get the auxiliary clock built and here’s a reminder of the clock circuit:</description></item><item><title>Auxiliary Control Design (Part 3 of 3)</title><link>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</link><pubDate>Wed, 07 Feb 2018 22:07:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</guid><description>This is the last post in a mini-series of three covering the design of the auxiliary control unit which will ease entering and inspecting programs in the computer’s memory. In my last post I covered the design of the auxiliary clock which resulted in the following schematic:
Auxiliary Clock Schematic (larger) … which generates the following timing pulses …
This post covers the last part of the puzzle which is designing the control logic that will take the pulses above and use them to drive the appropriate control lines at the right time according to the instruction the user requested as follows:</description></item><item><title>Auxiliary Control Design (Part 2 of 3)</title><link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</link><pubDate>Mon, 29 Jan 2018 22:12:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</guid><description>In my last post I made a start on the auxiliary control design which once completed will make it much easier to load instructions in to memory - effectively it’s a computer within a computer. If you haven’t read my previous post then it’s definitely worth doing so as this post picks up where that one left off. As a reminder though we’re looking to perform the following operations:
Auxiliary Control Operations Timing (larger) … which can be derived from the following pulses …</description></item><item><title>Auxiliary Control Design (Part 1 of 3)</title><link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</link><pubDate>Wed, 24 Jan 2018 21:24:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</guid><description>My relay computer is now at the point where it can execute a program in memory without assistance. In order to do that though, of course, the program needs to be loaded into memory in the first place and at the moment that’s a bit of a pain. For each line of the program you need to set the primary data switches to match the desired ‘opcode’, gate the switches to the data bus, gate the program counter to the address bus, gate the data bus to the memory and then write to the memory - that’s four buttons to press simultaneously. Once that’s done the program counter needs advancing ready for the next line of the program via holding the select PC and load INC buttons followed by select INC and load PC. This cycle is repeated for each line of the program until it’s all loaded into memory. Like I said, it’s a pain and there must be a better way to do this.</description></item><item><title>Fetch and Increment - Construction and Test</title><link>https://relaycomputer.co.uk/posts/2018/01/fetch-and-increment-construction-and/</link><pubDate>Tue, 16 Jan 2018 22:16:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/01/fetch-and-increment-construction-and/</guid><description>This is a bit of a landmark moment … at least for the construction of my relay computer. For a long time now my blog posts have been leading up to the point where my computer will execute a program in memory without any further input from the user. Well, it’s this post where that finally happens and all that stands in the way is a tweak to the sequencer and an addition to the controller unit. Here I’ll just stick to the pictures (and a video of course) but the design of the sequencer/controller changes is covered in this previous post.</description></item><item><title>Incrementer Test</title><link>https://relaycomputer.co.uk/posts/2018/01/incrementer-test/</link><pubDate>Sun, 07 Jan 2018 13:04:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2018/01/incrementer-test/</guid><description>In my last two posts I covered the construction of the upper and lower incrementer cards. The lower card is a 16-bit half adder and the upper card is a 16-bit register. Together they form the incrementer unit as a whole which can add one to whichever value is currently on the address bus and then hold that value ready for pushing back out to the address bus. More often than not the incrementer will be used to push the program counter on one place but in theory it can be used to increment any value put on the address bus.</description></item><item><title>Incrementer Construction (Part 2 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/12/incrementer-construction-part-2-of-2/</link><pubDate>Sun, 17 Dec 2017 12:32:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/12/incrementer-construction-part-2-of-2/</guid><description>In my last post I covered the construction of the lower incrementer card which is effectively a 16-bit half adder. This time I’m going to cover constructing the upper card of the incrementer which is a 16-bit register that can hold on to the incremented value before pushing it back out to the address bus.
The backplane connectors and LEDs were soldered down in my last post but there’s plenty more soldering to do. First up I can add the relay sockets, wire wrap posts and card interconnect wrap posts:</description></item><item><title>Incrementer Construction (Part 1 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/12/incrementer-construction-part-1-of-2/</link><pubDate>Sun, 10 Dec 2017 11:07:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/12/incrementer-construction-part-1-of-2/</guid><description>We’re getting nearer and nearer to a computer that can run though a program in memory rather than just a single instruction … we’ve got memory to hold the program and a program counter to point to the current instruction in memory. Now it’s time to construct the 16-bit incrementer which will be used to advance the program counter on to point at the next instruction.
As the incrementer is spread over two cards I’ll likewise spread the construction over two blog posts focussing this time on the lower card. Before that though I’ll get a head start and solder down the LEDs and backplane connectors for both cards:</description></item><item><title>Memory Test</title><link>https://relaycomputer.co.uk/posts/2017/11/memory-test/</link><pubDate>Thu, 30 Nov 2017 21:15:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/11/memory-test/</guid><description>I’ve covered the construction of the upper and lower memory cards in my last two posts … it’s now time to bring those two cards together to form the memory unit proper and give it all a test.
Here’s the upper card (in close up and at a rakish angle) …
… and here’s the lower memory card (at an equally rakish angle) …</description></item><item><title>Memory Construction (Part 2 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/11/memory-construction-part-2-of-2/</link><pubDate>Sat, 25 Nov 2017 16:52:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/11/memory-construction-part-2-of-2/</guid><description>In my last post I made a start on the memory unit construction with the lower memory card. The lower card centres around the memory IC which runs at 5V. The upper memory card picks up the task of converting the data and address bus coming in from the rest of the computer (running at 12V) to the 5V needed by the memory IC.
The LEDs and backplane connectors were soldered down in my last post so we can jump straight to adding the card interconnects which pass the local address/data busses to the lower card:</description></item><item><title>Memory Construction (Part 1 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/11/memory-construction-part-1-of-2/</link><pubDate>Sun, 19 Nov 2017 14:53:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/11/memory-construction-part-1-of-2/</guid><description>It’s time to make a start on the construction of the memory unit and as mentioned in my last post this one is a bit more complex than ‘boring old registers’ and so I’ll split it over two posts. Let’s dive in with the easy part - soldering down the LEDs and backplane connectors:
For the lower memory card there are 16 LEDs for the 16-bit address bus and 8 LEDs for the 8-bit data bus. Both of these busses are ’local’ to the memory unit and operate on +5V and ground as covered in my post on the memory unit design. Unfortunately I’ve messed up here a bit as I’ve merrily gone and soldered down the same LEDs I use on all the other cards … the 12V ones. Although these LEDs will work with 5V they won’t be as bright due to the internal resistor in each being rated for 12V operation. A bit of a silly mistake to make but it’s done and I’m not so upset by it that it’s worth changing them over … I only realised when I tested the card and noticed the LEDs weren’t as bright as usual (doh).</description></item><item><title>Program Counter Construction</title><link>https://relaycomputer.co.uk/posts/2017/11/program-counter-construction/</link><pubDate>Sat, 11 Nov 2017 10:25:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/11/program-counter-construction/</guid><description>In my last couple of posts I’ve been slightly distracted by some ‘miscellany’ but now I return to form and crack on with constructing the program counter. The program counter is effectively two 8bit registers bolted together and wired out slightly differently using the address bus rather than data bus. As usual I’ll start with soldering down the LEDs:
This should all be very familiar now and there’s nothing unusual about these LEDs compared to previous cards. I’m just about at the point now where I’ve ‘perfected’ the way of soldering and wiring these up after many iterations on previous cards. Next up is backplane connectors and relay sockets:</description></item><item><title>Miscellany Special: Backplane X, Cable Routing and Address Bus</title><link>https://relaycomputer.co.uk/posts/2017/11/miscellany-special-backplane-x-cable/</link><pubDate>Sun, 05 Nov 2017 10:47:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/11/miscellany-special-backplane-x-cable/</guid><description>Continuing on with the theme from my last post … here is another ‘miscellany special’ covering all the little ‘side jobs’ I’ve been doing on my relay computer alongside the primary work of constructing the Program Counter, Memory and Incrementer cards. There’s three things worth covering (plus an additional minor mention) … let’s start with backplanes.
The computer is designed with four backplanes (W, X, Y and Z) each taking five cards. Each card of the computer is designed to fit in a specific backplane as each backplane offers a unique selection of busses and connections. Generally you can put a card designated for a given backplane in to any of the five backplane slots (position mainly being an aesthetic thing) however the W backplane is the notable exception having slots W1 - W2 - W1 - W2 - W1 taking two double cards (with W1 and W2 connectors) and one single card (W1 connectors).</description></item><item><title>Miscellany Special: Power Distribution</title><link>https://relaycomputer.co.uk/posts/2017/10/miscellany-special-power-distribution/</link><pubDate>Sun, 29 Oct 2017 11:01:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2017/10/miscellany-special-power-distribution/</guid><description>Having somehow forgotten to take time off work I’m now playing ‘annual leave catch up’ which means lots of four day weeks but also, and more importantly for this blog, I’m getting time to crack on with construction of my relay computer. The current milestone I’m working towards is finishing off the Program Counter, Incrementer and Memory cards (which are all well under way now) so that I can load a simple program in to the computer and set it running without any further intervention.</description></item><item><title>Control Design: Fetch and Increment</title><link>https://relaycomputer.co.uk/posts/2017/09/control-design-fetch-and-increment/</link><pubDate>Sun, 17 Sep 2017 12:57:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/09/control-design-fetch-and-increment/</guid><description>The design of the computer’s memory, incrementer and program counter are now complete but there’s one last piece of the ‘puzzle’ required to get the computer running a program. The controller now needs updating to orchestrate the ‘fetch and increment’ cycle. This cycle retrieves the next instruction from memory (into the instruction register) and then increments the program counter to point at the next instruction in memory. In this post I’ll cover the changes needed to the controller cards to implement this cycle.</description></item><item><title>Memory Design (Part 2 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-2-of-2/</link><pubDate>Wed, 06 Sep 2017 22:55:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-2-of-2/</guid><description>In my last post I started the design for the computer’s memory unit which is spread over two cards. With the lower memory card design in place its now time to finish the job and design the upper card which will interface the rest of the computer with the memory chip of the lower card.
Let’s dive straight in by bringing up the board interconnects from the lower card:
Memory Card A with initial interconnects (larger) The left two columns bring up the address bus for the memory chip which needs to be at 5V for a logic 1 and at ground for a logic 0. The third column brings up the outbound data bus which will sink 12V to ground for a logic 1 but holds at 12V for a logic 0 (effectively an inverse of what you’d expect). The fourth column brings up the inbound data bus which takes 5V for 1 and ground for 0 along with the write enable (WE) control line and output enable (OE) line which work in reverse (5V for disabled and ground for enabled). The last three connects to the right are power at 12V, ground for 5V and finally 5V. As you can probably guess there’s going to need to be quite a lot of ’translation’ logic on this card.</description></item><item><title>Memory Design (Part 1 of 2)</title><link>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-1-of-2/</link><pubDate>Sun, 03 Sep 2017 22:35:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-1-of-2/</guid><description>In my last post I explained my decision to use a ‘modern’ memory chip in my relay computer … I also alluded to there being some complexities in interfacing the rest of the computer with that memory chip. The memory unit will be spread over two cards and in this post I cover the design of the first half and expand on those ‘complexities’ a bit.
The memory chip I’m using is from the ‘62’ family of CMOS 256Kbit (32K x 8) Static RAM … effectively meaning it can store 32,768 separate 8 bit values referenced by a 15bit address bus. Buying chips can be a bit of a ’needle in a haystack’ when you’re buying through one of the larger electronics suppliers (I use Mouser). Knowing the chip number isn’t enough to actually buy one and doing a search on Mouser for ‘62256 memory’ narrows it down to 61 matches. I can narrow it down further as I know I need through-hole mounting (not surface mount) and that gets me to 6 matches. Next choice is access speed … 55ns or 70ns. This is actually a bit of a mute point for this computer as it’ll get nowhere near that speed (the relays take around 5ms to switch) so lets ignore that one. So faced with 6 choices it comes down to price and what’s in stock. In the end I went for a mid-priced chip from Cypress Semiconductor … a CY62256NLL-70PXC for £2.77 (‘cheap as chips’ … literally).</description></item><item><title>The problem with memory</title><link>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</link><pubDate>Fri, 18 Aug 2017 22:58:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</guid><description>It’s time, at last, to start looking at the design for the computer’s memory and this is a bit of a game changer as it’s the final part of the jigsaw that lets the computer run a program. However, it’s also the part of the computer that leaves me in a bit of a quandary.
The problem with memory is that typically you need quite a lot of it and that’s something that doesn’t come easy with relays. In a way the registers already present in the computer are a kind of memory … they store a single byte of data. So, effectively you can get two bytes worth of storage on one of the usual computer cards. You can maybe see where this is going.</description></item><item><title>More Laser Cut Parts</title><link>https://relaycomputer.co.uk/posts/2017/08/more-laser-cut-parts/</link><pubDate>Sun, 06 Aug 2017 13:13:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/08/more-laser-cut-parts/</guid><description>I’ve nearly got the design for the memory cards done and ready to share but once that’s out the way it’ll be time to get on with some construction again. With that in mind I cracked out the credit cards and got buying more relays plus some other bits and bobs and whilst I was in a spending mood I decided it was high time to treat the computer to some more laser cut parts.</description></item><item><title>Incrementer Design</title><link>https://relaycomputer.co.uk/posts/2017/07/incrementer-design/</link><pubDate>Mon, 17 Jul 2017 21:34:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/07/incrementer-design/</guid><description>In my last post I covered the design of the 16-bit half adder which takes whatever value is currently on the address bus and increments it by one. To make this incremented value useable we need to create a register so that we can store the value ready for pushing back on to the address bus. Typically this incremented value would then be loaded into the program counter to get it ready for the next instruction in memory.</description></item><item><title>Incrementer Design: 16-bit Half Adder</title><link>https://relaycomputer.co.uk/posts/2017/07/incrementer-design-16-bit-half-adder/</link><pubDate>Sat, 15 Jul 2017 14:57:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/07/incrementer-design-16-bit-half-adder/</guid><description>In the last post I introduced the design for the 1-bit Half Adder. This post covers connecting sixteen of these units together to make the 16-bit Half Adder.
So, diving straight in, here is what sixteen of the 1-bit Half Adder units look like all together on the usual 55 x 40 hole pad board:
16 x 1-bit Half Adder Units (larger) Each half adder bit is made up of two relays (as seen in the previous blog post) and starting at the bottom right of the diagram above the bit stages run upwards from 0 to 3 and then continuing on in rising columns to the left until bit 15 at the top left. Between each bit the carry out lines of the prior bit are connected to the carry in and the carry out lines connect to the carry in of the next bit effectively chaining each bit together to form a ripple carry adder circuit.</description></item><item><title>Incrementer Design: 1-bit Half Adder</title><link>https://relaycomputer.co.uk/posts/2017/06/incrementer-design-1-bit-half-adder/</link><pubDate>Sun, 04 Jun 2017 22:42:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/06/incrementer-design-1-bit-half-adder/</guid><description>Typical isn’t it?! … you wait 10 months for a post and then two come along at once. Well, all being well, this should be the first of a short flurry of posts as I move on to the design of the incrementer.
The incrementer takes any value currently on the 16-bit address bus and adds one to it, or rather, it increments it (clue is in the name of course). Typically that value on the address bus is going to come from the program counter (in order to point it at the next instruction in memory) but it’ll also be possible to bump the upcoming XY register eventually too.</description></item><item><title>Register Design: Program Counter</title><link>https://relaycomputer.co.uk/posts/2017/05/register-design-program-counter/</link><pubDate>Mon, 29 May 2017 17:13:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2017/05/register-design-program-counter/</guid><description>It’s been a while since my last post … pretty much 10 months in fact … and I’d love to say I’ve been quietly working on my relay computer in the meantime but I haven’t. Designing, building and blogging about the various parts of the computer is really time consuming and unfortunately I’m just one of those people who has way too many hobbies. Anyway, after picking up some subscribers on YouTube I thought it was high time (or maybe I felt guilty enough) to focus back on the computer and get it through to the next milestone … where it can step through a simple program stored in its memory without any human intervention (beyond entering the program itself and setting the computer running).</description></item><item><title>Yet another diversion</title><link>https://relaycomputer.co.uk/posts/2016/07/yet-another-diversion/</link><pubDate>Sun, 24 Jul 2016 22:13:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2016/07/yet-another-diversion/</guid><description>It’s been a bit quiet on the relay computer front again for a while … well it is summer after all and there’s no point staying inside the house tending to my hobbies when I can be running around outside getting sunburnt. Of course though, this is the UK and summer consists mostly of rain (as do most of the other seasons here) so what other excuse do I have for not posting in ages?</description></item><item><title>Sequencing &amp; Control Test</title><link>https://relaycomputer.co.uk/posts/2016/05/sequencing-control-test/</link><pubDate>Tue, 24 May 2016 21:12:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2016/05/sequencing-control-test/</guid><description>It’s finally time to give all the cards created so far a test so I can check everything works together as expected. This represents quite a bit of a milestone as the computer can now perform a single ALU, SETAB or MOV-8 instruction. This means a user can technically run a program by entering and running each instruction in turn and although the computer is still a long way from completion with this latest round of functionality it’s a lot more usable than before.</description></item><item><title>W Backplane Construction &amp; Power Distribution</title><link>https://relaycomputer.co.uk/posts/2016/04/w-backplane-construction-power/</link><pubDate>Mon, 11 Apr 2016 21:07:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2016/04/w-backplane-construction-power/</guid><description>Before I can test the new decoder, sequencer and controller cards all working together with the rest of the computer I need to construct the ‘W’ backplane which the new cards sit on. Generally this backplane is similar in design to the ‘Z’ backplane that the ALU cards and A/D and B/C register cards sit on. However, whereas each card on the Z backplane has the exact same connectors the W backplane is slightly more complex as the sequencer and control units are spread over two cards each requiring a different set of connectors. The upshot is that the backplane has three ‘W1’ card slots and two ‘W2’ card slots. A diagram explains it better:</description></item><item><title>User Interface Construction: Instruction, Clock and Sequencer</title><link>https://relaycomputer.co.uk/posts/2016/03/user-interface-construction-instruction/</link><pubDate>Tue, 29 Mar 2016 22:38:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2016/03/user-interface-construction-instruction/</guid><description>Well, the good news is I’ve just passed a major milestone in constructing this relay computer … it can now perform a single instruction in full firing the various control lines as needed. The bad news … I’m rather behind in blogging about it so this will be the first of a couple of ‘catch up’ posts which will culminate in a video showing off the computer as it currently stands.</description></item><item><title>Controller Construction: MOV-8, ALU and SETAB</title><link>https://relaycomputer.co.uk/posts/2016/01/controller-construction-mov-8-alu-and/</link><pubDate>Fri, 01 Jan 2016 23:23:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2016/01/controller-construction-mov-8-alu-and/</guid><description>So yea, it’s been a while since my last post … in fact it’s been just over six months. For some reason I decided I didn’t have enough to do in the evenings so had a crack at becoming an actuary. Needless to say I’ve been busy studying for my entry exams and so the computer took a back seat for a while. Exams are done for now though so the computer is back on and I’m back constructing to get the MOV8, ALU and SETAB instructions running.</description></item><item><title>Sequencer Construction: 8-cycle FSM</title><link>https://relaycomputer.co.uk/posts/2015/07/sequencer-construction-8-cycle-fsm/</link><pubDate>Wed, 08 Jul 2015 09:27:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/07/sequencer-construction-8-cycle-fsm/</guid><description>I’m just about at the half way mark now for getting the computer to operate the MOV8, ALU and SETAB instructions. The easier cards are out of the way now … time for the slightly more complex ones. In this post it’s the sequencer cards which will deal with the ‘when’ of instructions by sending out timing pulses which the upcoming control cards will then use to operate the various control lines of the computer at the right time.</description></item><item><title>Decoder Construction: MOV-8, ALU &amp; SETAB</title><link>https://relaycomputer.co.uk/posts/2015/06/decoder-construction-mov-8-alu-setab/</link><pubDate>Sun, 07 Jun 2015 21:43:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/06/decoder-construction-mov-8-alu-setab/</guid><description>In a change from prior form I’m combining the construction and testing of the next card in to a single post this time. Partly because this card is a nice easy one but also because it’s the first card that I’ll be partially constructing to begin with and then I’ll return to it later to add further functionality.
The card in question is the decoder which will take the value on the instruction bus and use it to decide which instruction class it represents. This class will then be used by the upcoming control card along with the sequencer pulses to operate the various control lines of the computer in the appropriate order. To begin with the decoder will recognise MOV8, ALU and SETAB instruction classes but there’ll be more added later on.</description></item><item><title>Register Construction: Completed Instruction Register Full Test</title><link>https://relaycomputer.co.uk/posts/2015/05/register-construction-completed/</link><pubDate>Sat, 16 May 2015 10:19:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/05/register-construction-completed/</guid><description>Following on from my last post, and after popping in some relays, the instruction register is complete and looks like this:
As usual I’ve put a video together that demonstrates this card in operation. In this video I give a quick overview of the card and then demonstrate loading values in to the register and instruction bus. I also demonstrate gating part of the instruction bus on to the data bus for the I2B (Immediate to Bus) functionality.</description></item><item><title>Register Construction: Instruction Register</title><link>https://relaycomputer.co.uk/posts/2015/05/register-construction-instruction/</link><pubDate>Sat, 09 May 2015 20:01:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/05/register-construction-instruction/</guid><description>There’s been lots of theory going on in my recent posts but the time for design is over (for now) … it’s time to get constructing. The first card up in this batch is the instruction register and as it shares much of its design with the other register cards the construction is very similar.
The first step is to solder down the LEDs. Here’s some pictures, front and back, of the card following this first round of soldering:</description></item><item><title>New Workbench</title><link>https://relaycomputer.co.uk/posts/2015/05/new-workbench/</link><pubDate>Mon, 04 May 2015 11:19:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/05/new-workbench/</guid><description>Those who have been reading my posts and watching my videos (you have my sympathy) will know that alongside constructing this computer I’ve also been busy renovating a house I bought almost a year ago. This is mostly why there’s been a lot of theory and design going on for the relay computer and not much construction … I haven’t actually had anywhere to do the construction … until now that is.</description></item><item><title>User Interface Design: Instruction, Clock and Sequencer</title><link>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</link><pubDate>Wed, 08 Apr 2015 23:19:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</guid><description>Over my last seven posts I’ve been slowly putting together the card designs so that the computer will be able to operate the MOV-8, ALU and SETAB instructions. The final step in this series is to update the designs for the two display cards along with the main switches to work with the new cards added recently.
Diving straight in here is the latest version of the Display A design:</description></item><item><title>Control Design: MOV-8, ALU and SETAB (part 2 of 2)</title><link>https://relaycomputer.co.uk/posts/2015/04/control-design-mov-8-alu-and-setab-part/</link><pubDate>Sat, 04 Apr 2015 08:06:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/04/control-design-mov-8-alu-and-setab-part/</guid><description>In part one of this two part post I introduced the design of the control relays for each of the MOV-8, ALU and SETAB instructions. With these in hand I can now move on to placing these on the control cards and wire everything together. That’s ‘cards’ rather than ‘card’ as the control relays will be spread over two cards just like the sequencer relays are. This is partly because there’s more relays than would fit on a single card but mainly because access to a wider range of busses is needed.</description></item><item><title>Control Design: MOV-8, ALU and SETAB (part 1 of 2)</title><link>https://relaycomputer.co.uk/posts/2015/03/control-design-mov-8-alu-and-setab-part/</link><pubDate>Tue, 31 Mar 2015 22:26:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2015/03/control-design-mov-8-alu-and-setab-part/</guid><description>Over the last five posts I’ve been building up the design of a set of cards so that the computer will be able to understand and perform the MOV-8, ALU and SETAB instructions. In this post I’m putting together the final piece of the jigsaw … the control card. This will take the instruction class from the decoder (which derives its result from the instruction register) along with the pulses generated by the sequencer to operate the various control lines of the computer as required.</description></item><item><title>Pulse Distribution Design: Pulses C,D and E</title><link>https://relaycomputer.co.uk/posts/2015/03/pulse-distribution-design-pulses-cd-and/</link><pubDate>Sun, 22 Mar 2015 13:58:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2015/03/pulse-distribution-design-pulses-cd-and/</guid><description>In my last post I covered the design of the 8-cycle finite state machine (FSM). In this post I’ll now take the outputs from that FSM and combine them to produce the timing pulses that will be needed to perform the MOV-8, ALU and SETAB instructions. The sequencer and pulse distribution share a ‘double’ card and so I’ll also cover the resulting design when these two systems are combined.
To quickly recap … the 8-cycle FSM will produce the following states given a clock signal as an input:</description></item><item><title>Sequencer Design: 8-cycle FSM</title><link>https://relaycomputer.co.uk/posts/2015/01/sequencer-design-8-cycle-fsm/</link><pubDate>Mon, 26 Jan 2015 22:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2015/01/sequencer-design-8-cycle-fsm/</guid><description>So far I’ve got the design complete for the instruction register along with the initial design for the decoder and so I’m well on the way to having the computer perform MOV-8, ALU and SETAB instructions. Later I’ll get on to the control card design where the computer will operate the control lines according to the 8-bit opcode stored in the instruction register. Before that though there’s the sequencer card which will generate the pulses that drive the control card.</description></item><item><title>Decoder Design: MOV-8, ALU &amp; SETAB</title><link>https://relaycomputer.co.uk/posts/2015/01/decoder-design-mov-8-alu-setab/</link><pubDate>Sun, 04 Jan 2015 22:12:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2015/01/decoder-design-mov-8-alu-setab/</guid><description>In my last post I introduced the design for the instruction register which holds the current 8-bit opcode that the computer is executing. The next card to design is the decoder which will take the 8-bit opcode and set either the MOV-8, ALU or SETAB control lines depending which class of instruction the opcode represents. This is actually quite straightforward and just needs a few relays to handle the logic.</description></item><item><title>Register Design: Instruction Register</title><link>https://relaycomputer.co.uk/posts/2014/12/register-design-instruction-register/</link><pubDate>Mon, 01 Dec 2014 21:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/12/register-design-instruction-register/</guid><description>Well, it’s fair to say that I rather underestimated just how much time decorating the new house would take up … and that’s mainly because ‘decorating’ included re-wiring, re-plumbing, re-plastering, re-carpeting … all before I got anywhere near choosing a tasteful shade of emulsion for the walls. Needless to say then that spending time on my relay computer has suffered quite a bit. However, things are starting to calm down (now that there’s two rooms in the house that are semi-habitable) so I can get back to designing the next bits for the computer.</description></item><item><title>Sequencing &amp; Control Design: Overview</title><link>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</link><pubDate>Fri, 19 Sep 2014 23:27:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</guid><description>I’ve now got my computer to a state where I can perform ALU operations and push values around the four registers by manually operating the various control lines. It’s time to move things on a bit now and work towards getting the computer to the point where given a specific instruction/op-code it can operate the control lines itself without further input from the user. Eventually the computer will be given a list of instructions to perform which it’ll work through step by step but for now the next milestone is to automate the operation of a single instruction.</description></item><item><title>ALU &amp; Registers A-D Test with new Display Cards</title><link>https://relaycomputer.co.uk/posts/2014/08/alu-registers-d-test-with-new-display/</link><pubDate>Tue, 19 Aug 2014 18:22:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/08/alu-registers-d-test-with-new-display/</guid><description>Now that the two display cards are complete enough to display and control the status of the ALU and four registers (A-D) it’s time to fit them to the upper enclosure. With that done the upper enclosure can then be connected to the lower enclosure and everything can be given a test together.
The upper enclosure is constructed very similarly to the lower enclosure … as before, out of aluminium profile. Here’s a Sketchup image of how the upper enclosure should look when sat on top of the lower enclosure:</description></item><item><title>User Interface: Display B Initial Design and Construction</title><link>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-b-initial-design/</link><pubDate>Sun, 20 Jul 2014 10:05:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-b-initial-design/</guid><description>In my last post I put together the beginnings of the first display card … named in a brilliant flash of nomenclature as display card A. This time I’m turning my attention to the second display card … named (can you guess) display card B.
Whereas display A is dual purpose allowing a user to view and initiate control signals the second display card is read-only and displays the primary state of the computer. Initially this ‘primary state’ comprises of the data bus contents, condition register status and ALU function code / operation. I also had a rectangular gap spare on the card that looked like it’d fit an ammeter so that also now forms part of the second display too.</description></item><item><title>User Interface: Display A Initial Design and Construction</title><link>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-initial-design/</link><pubDate>Sat, 12 Jul 2014 10:31:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-initial-design/</guid><description>Following on from working on the main data switches in my last post this time I’ve taken the first steps in designing and constructing the first of two display cards which will sit in the upper enclosure. The first card (display A) has a dual purpose … it provides a display to show which control signals are in operation between the various parts of the computer but also allows the operator to manually control those signals when the computer is set to a special ‘diagnostic’ mode.</description></item><item><title>User Interface: Data Switches</title><link>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</link><pubDate>Sat, 05 Jul 2014 09:40:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</guid><description>Now I’ve got a fully working ALU and four registers completed I want to take a short break from card building and turn my attention to making it easier to interact with the computer. Currently I’m controlling the computer via a set of DIP switches which is incredibly fiddly so it’s time to construct something ‘chunkier’.
The switches I’m going to concentrate on first are the primary data switches which permit values to be placed on the data bus. These switches won’t be directly connected to the data however because as a user you’d have to keep turning them all off so the computer can use the bus … instead I’ll build a gating circuit so the value on the switches can be placed on and off the bus as needed. Additionally the gating circuit will also allow the values on the switches to be gated over to the lower 8 bits of the 16 bit address bus. This will allow the quick setting of addresses once the computer gains its memory card and register. I was originally thinking of having a separate set of 16 switches for setting the address bus but decided in the end that I didn’t want to use the space up for something I didn’t think would get used that much. The upshot of this is that to set the upper 8 bits of the address bus requires gating the switches to the data bus and then loading the higher 8 bits on one of the 16 bit registers (like the upcoming M2, Y and J2 registers). That said, at the moment everything is manual until I build the data and address load circuitry so for now gating the switches on to the data bus would always be followed by a manual register load operation.</description></item><item><title>Register Construction: Completed A and D 8-bit Registers Full Test</title><link>https://relaycomputer.co.uk/posts/2014/06/register-construction-completed-and-d-8/</link><pubDate>Sat, 28 Jun 2014 13:12:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/06/register-construction-completed-and-d-8/</guid><description>The A/D Register card is now complete and looks like this:
As usual I’ve put a video together that demonstrates this card in operation. This time I don’t show testing the card on its own as the A/D register is pretty much the same as the B/C register shown last time around … needless to say I did test the card fully off camera and everything worked fine (first time believe it or not). As I’ve now got the three ALU cards and four registers I’m finally able to perform multiple operations and accumulate the result. I demonstrate this in the video by performing a series of arithmetic operations by hand.</description></item><item><title>Register Construction: A and D 8-bit Registers</title><link>https://relaycomputer.co.uk/posts/2014/06/register-construction-and-d-8-bit/</link><pubDate>Sun, 22 Jun 2014 18:35:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/06/register-construction-and-d-8-bit/</guid><description>I haven’t posted in nearly a month but in between bouts of enjoying the rare British sunshine I’ve been plodding away at the A/D register card and it’s now finally ready for testing. The A/D register card is effectively a slightly simplified version of the previously covered B/C card and so a lot of the content in this post is going to be pretty similar. Despite this though I’ll go through all the steps taken to construct the A/D register card for the sake of completness … primarily in photos and then with extra text where anything odd or different came up compared with the B/C card.</description></item><item><title>Register Construction: Completed B and C 8-bit Registers Full Test</title><link>https://relaycomputer.co.uk/posts/2014/05/register-construction-completed-b-and-c/</link><pubDate>Mon, 26 May 2014 09:59:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/register-construction-completed-b-and-c/</guid><description>The B/C Register card is now complete and looks like this:
As usual I’ve put a video together which demonstrates this card in operation … firstly on its own but then together with all the other cards constructed so far. Hopefully these videos are ‘adding value’ and are worthwhile (they really do take ages to put together … this one took about 5 hours effort in total for 20 mins of video). Please do leave any comments, good or bad, either here on the blog or on YouTube against the video or feel free to ask any questions about the computer as although I know this is a pretty niche subject I can’t help feeling I’m talking to myself ;)</description></item><item><title>Register Construction: B and C 8-bit Registers</title><link>https://relaycomputer.co.uk/posts/2014/05/register-construction-b-and-c-8-bit/</link><pubDate>Sat, 24 May 2014 17:23:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/register-construction-b-and-c-8-bit/</guid><description>As mentioned in my last post I decided this time around not to post after each stage of card construction (being as the construction steps are now pretty similar to those for previous cards). In line with that decision this post covers all the steps taken to construct the B/C register card … primarily in photos and then with extra text where anything odd or different came up compared with the other cards completed so far.</description></item><item><title>Register Design: B and C 8-bit Registers</title><link>https://relaycomputer.co.uk/posts/2014/05/register-design-b-and-c-8-bit-registers/</link><pubDate>Sun, 11 May 2014 10:08:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/register-design-b-and-c-8-bit-registers/</guid><description>In a recent post I put up the design for the A and D 8-bit register card … the B and C register card is very similar in design but has the additional complexity that it has to directly feed the ALU. In another recent post I covered how to take multiple outputs from a relay without risking back-feed by utilising diodes in the output line. This post therefore brings together those two designs and although it’s essentially a re-hashing of the AD card post but with extra bits I’ll go through the design as I did with the AD card so that this post stands alone as it were.</description></item><item><title>Enclosure Update: Magic Pen</title><link>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-magic-pen/</link><pubDate>Sat, 10 May 2014 09:46:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-magic-pen/</guid><description>Just need to quickly share my experience with what I’m dubbing the ‘magic pen’ before I put up the B/C register schematics (yup, they’re finally ready). If you’ve read my recent posts you’ll know I ordered in some laser cut acrylic parts for my enclosure including one part which is engraved as well as cut for the switch panel. Close up it looks like this:
Only problem now is I’ve got tons of cleaning fluid left and a pen mostly full of paint so I’m off now to find things around the house to draw on.</description></item><item><title>Enclosure Update: Fitting of Laser Cut Parts</title><link>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-fitting-of-laser-cut/</link><pubDate>Mon, 05 May 2014 11:03:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-fitting-of-laser-cut/</guid><description>I was going to spread the fitting of the laser cut parts to the lower enclosure over a couple of evenings but in a fit of geeky excitement I ended up doing it all in one evening. Fortunately I didn’t damage anything in my ‘rush’ (although I had to accept a few niggles) and it went something along this lines of this …
First job was to fit the panels in to the front and rear door frames. As is often the case with these things I had this picture in my head of the panels popping straight in the frames with no fuss … a picture which always seems to differ substantially with the real life experience. To say this thing was a tight fit is an understatement. I started off with a U shaped frame and the idea was to slide the panel in from the top but as the panel moves further down it builds up more and more friction resistance in the plastic panel holder strips. In the end I took the frame apart and built it back up again around the panel but even with this it certainly took some considerable arm strength to persuade it to go together. After much perspiration the panel was in and looks like this:</description></item><item><title>Enclosure Update: Laser Cut Parts Arrived</title><link>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-laser-cut-parts-arrived/</link><pubDate>Sat, 03 May 2014 09:49:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/05/enclosure-update-laser-cut-parts-arrived/</guid><description>I’ve been looking forward to this moment for nearly a month … the laser cut parts I ordered to move my enclosure construction forward have finally arrived.
The picture on the left is viewing the part from the top side and the one on the right from the underside. The part was cut with the top side facing up and so the bottom side has picked up plenty of burn marks which is reasonably inevitable when cutting plywood with a laser. The odd hexagon shaped burns on the underside come from, I think, the cutting bed which has a lattice structure with this shape. All of these burn marks can be carefully sanded away but I actually quite like them … a mark of its provenance if you like.</description></item><item><title>Register Design: Dual Output 8-bit Register</title><link>https://relaycomputer.co.uk/posts/2014/04/register-design-dual-output-8-bit/</link><pubDate>Thu, 24 Apr 2014 22:56:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/04/register-design-dual-output-8-bit/</guid><description>In the last post I introduced the design for the A/D register card (which as its name suggests contains the A and D 8-bit registers). I’m now making a start on the design for the B/C register card and although its pretty much the same as the A/D card there’s an extra complexity because the B/C registers additionally feed the ALU B and C inputs.
For the A and D registers I ended up with the following circuit per 8-bit register:</description></item><item><title>Register Design: A and D 8-bit Registers</title><link>https://relaycomputer.co.uk/posts/2014/04/register-design-and-d-8-bit-registers/</link><pubDate>Sun, 20 Apr 2014 11:15:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/04/register-design-and-d-8-bit-registers/</guid><description>In the last post I introduced the design for a general purpose 8-bit register. This post covers taking two of those registers along with status LEDs and gating relays to implement the full A and D registers.
So, diving straight in, here is what the main bit relays look like for the two 8-bit registers when placed on the usual 55 x 40 hole pad board (excluding wire links):
2 x 8 bit register relays (larger) Each of the relays above stores a single 1-bit value so there’s 16-bits worth in total (which could all be used together if we were making a 16-bit register) or two lots of 8-bits (for our two 8-bit registers). Each of the 1-bit register relays need gating to and from the data bus so that the values stored don’t conflict with any other value on the data bus. With these additional control and gating relays added we get the following (this time including internal wire links in the 1-bit register relays and result links between the 1-bit register relays and the gating relays):</description></item><item><title>Register Design: General Purpose 8-bit Register</title><link>https://relaycomputer.co.uk/posts/2014/04/register-design-general-purpose-8-bit/</link><pubDate>Wed, 16 Apr 2014 22:08:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/04/register-design-general-purpose-8-bit/</guid><description>This post covers the design of a general purpose 8-bit register that can be loaded from the data bus and then selected back to the data bus at a later time. This permits temporary storage of 8-bit values whilst performing various operations, for example, ALU functions. This post goes back over some of the ground already covered by the design of the condition registers which are a slightly simplified version of the registers detailed here.</description></item><item><title>Enclosure Update: Laser Cutting</title><link>https://relaycomputer.co.uk/posts/2014/04/enclosure-update-laser-cutting/</link><pubDate>Thu, 10 Apr 2014 19:58:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/04/enclosure-update-laser-cutting/</guid><description>I couldn’t resist it any longer … I’ve ordered the laser cut parts for the case doors, sides and bay floor/ceilings. I did say I’d wait for my chosen laser cut website to put out a free delivery offer but I ended up crumbling under the weight of my own impatience. Needless to say within 24 hours of placing my order they announced a free delivery offer for the end of April … c’est la vie and all that jazz.</description></item><item><title>Completed ALU</title><link>https://relaycomputer.co.uk/posts/2014/03/completed-alu/</link><pubDate>Sun, 30 Mar 2014 12:15:00 +0100</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/completed-alu/</guid><description>Following my last post on the completed backplane I’m now in a position to connect all the other completed cards together to test the full ALU. The ALU is made up of the logic, arithmetic and control cards and here’s how those cards look when plugged in to the backplane:
… and when viewed from the top and back …
… and finally here’s the four cards laid out side by side:</description></item><item><title>ALU Construction: Completed Backplane</title><link>https://relaycomputer.co.uk/posts/2014/03/alu-construction-completed-backplane/</link><pubDate>Wed, 26 Mar 2014 21:57:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/alu-construction-completed-backplane/</guid><description>In my last post I mentioned I’d suffered a bit of a set back with the construction of the ALU backplane. Well, the short version of things is that I’ve admitted defeat and constructed a new backplane using a different design … it looks like this:
This design uses stackable headers instead of regular sockets so that the pins extend out of the back of the card far enough to attach an IDC connector. Each of these connectors can then be ‘daisy chained’ together with ribbon cable making construction relatively quick and easy to do.</description></item><item><title>Enclosure Initial Construction</title><link>https://relaycomputer.co.uk/posts/2014/03/enclosure-initial-construction/</link><pubDate>Sat, 22 Mar 2014 00:08:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/enclosure-initial-construction/</guid><description>I’ve been promising this post for quite a while now … an update on how the enclosure construction is going. Well, it’s very good thanks :)
Firstly, here’s a quick reminder of the SketchUp design showing how the enclosure should look:
… and here’s how it looks, so far, in reality …
This is the main frame of the card enclosure and you can see it forms four compartments that will hold five cards each plus backplanes. At the moment the front and back doors are incomplete as they’re waiting for the perspex/acrylic sheet (3mm smoked transparent) to be cut. Likewise the perspex that fits in the sides of the main frame are also pending. Because of this the frame as it appears above isn’t fully screwed together yet … the back bars (which kind of form a shape like two ‘E’s back to back) are just held in by friction on the corners. Once the side perspex panels are in then everything can be screwed together and a very rigid strong frame results. All the joints are held together with self tapping torx screws which are driven into the end of a piece of profile and then the screw head rests in the slot of a second piece of profile and is tightened with a screw driver via a drilled access hole.</description></item><item><title>ALU Construction: Completed Control Card Full Test</title><link>https://relaycomputer.co.uk/posts/2014/03/alu-construction-completed-control-card/</link><pubDate>Sun, 16 Mar 2014 08:59:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/alu-construction-completed-control-card/</guid><description>The ALU Control Card is now complete and looks like this:
This card was, on the whole, much simpler and quicker to put together than previous cards (despite me initially messing up the zero detection relay positions). As the card isn’t too busy I’ve arranged the wiring away from the empty part of the card so there’s room for future expansion or modifications if needed in the future. Not entirely sure what they’d actually be but you never know.</description></item><item><title>ALU Construction: Control Card Power Rails &amp; Wire Wrap</title><link>https://relaycomputer.co.uk/posts/2014/03/alu-construction-control-card-power/</link><pubDate>Fri, 14 Mar 2014 19:51:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/alu-construction-control-card-power/</guid><description>I’ve been a bit short of time lately so I’ve been working on the ALU Control Card in little bursts … but after lots of these little bursts I’ve now got all the power rails and wire wrap done for this card.
Here’s the card as it currently stands:
… and this is how the power rails look on the solder side of the card …</description></item><item><title>ALU Construction: Control Card Header Pins &amp; Relay Sockets</title><link>https://relaycomputer.co.uk/posts/2014/03/alu-construction-control-card-header/</link><pubDate>Tue, 04 Mar 2014 18:03:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/alu-construction-control-card-header/</guid><description>Following on from the first two successfully completed ALU cards, for logic and arithmetic, it’s time to make a start on the control card (well, actually, the LEDs and connectors are already done from earlier but you get the gist). The control card performs three functions: control registers, function decoding and zero detection … and thankfully this card is much simpler than the previous two in terms of relay count and sheer amount of soldering so should come together relatively quickly.</description></item><item><title>Enclosure Disclosure</title><link>https://relaycomputer.co.uk/posts/2014/03/enclosure-disclosure/</link><pubDate>Sat, 01 Mar 2014 10:55:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/03/enclosure-disclosure/</guid><description>Sorry, I will try to rain in the terrible punning post titles.
This time I wanted to share the thoughts and ideas I’ve been having around building a case to hold my computer when it’s eventually complete. I wanted to use a material that would be easy to handle and work with but also one that would produce a nice looking result. I was initially drawn to using wood or possibly even laser cut plywood but in the end I settled on aluminium profile as its sturdy, easy to assemble and, I think, looks really great. In addition to this it’s available in a large variety of sizes, shapes and there’s plenty of fixtures and fittings available for it.</description></item><item><title>ALU Construction: Completed Arithmetic Card Full Test</title><link>https://relaycomputer.co.uk/posts/2014/02/alu-construction-completed-arithmetic/</link><pubDate>Sun, 23 Feb 2014 17:31:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/02/alu-construction-completed-arithmetic/</guid><description>The ALU arithmetic card is now complete! The final card looks like this:
As I did for the ALU logic card before I’ve put the following YouTube video together which gives a walkthrough of the arithmetic card in operation … and as before this one also has a narrative track delivered by my own fair gob.
So, that’s two out of the three ALU cards done with just the control card left to do. Well, I say that … after the ALU is completed there’s all those registers let alone all the control and timing circuitry coming up … I’ll try not to think too much about the impending work for now.</description></item><item><title>ALU Construction: Arithmetic Card Wire Wrap 2</title><link>https://relaycomputer.co.uk/posts/2014/02/alu-construction-arithmetic-card-wire_19/</link><pubDate>Wed, 19 Feb 2014 22:37:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/02/alu-construction-arithmetic-card-wire_19/</guid><description>I’ve managed to squeeze in a couple more wire wrapping sessions this week so in this post there’s a few photos of progress so far.
Inputs B and C are fully wired in now as is the data bus output. As all the wiring is now complete on the arithmetic 1-bit units I’ve popped the relays in.
The next wire links to add are the control lines which select either the Add or Increment operation and then once that’s done the card should be ready for powering up and testing/debugging.</description></item><item><title>ALU Construction: Arithmetic Card Wire Wrap 1</title><link>https://relaycomputer.co.uk/posts/2014/02/alu-construction-arithmetic-card-wire/</link><pubDate>Sun, 16 Feb 2014 10:04:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/02/alu-construction-arithmetic-card-wire/</guid><description>Fear not (just in case you were for some reason) all this talk of Sketchup and enclosures and so on hasn’t totally diverted me from the main task of constructing the ALU. The wire wrap is coming along nicely on the arithmetic card although it has taken slightly more concentration than before to get all the wraps in the right places.
Here’s a couple of pictures showing the card in its current state of progress:</description></item><item><title>Sketchy Diversion</title><link>https://relaycomputer.co.uk/posts/2014/02/sketchy-diversion/</link><pubDate>Tue, 04 Feb 2014 19:10:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/02/sketchy-diversion/</guid><description>I’m taking a break … just a short one.
In between all the bouts of wire wrapping for the ALU arithmetic card I’m starting to think about enclosure options for the computer when it’s finally (finally!) finished. I’ve been trawling the internet for inspiration and I’m starting to get a feel for the sort of materials and finish I want and I’ve even been getting some prototype laser etching done (more on this in a later post). One thing I’m finding as I’m going along though is that I’m trying to picture things in my head and there’s a lot of guesswork going on. What I need is to employ some CAD so I can make sure things fit together before really fitting them together.</description></item><item><title>ALU Construction: Arithmetic Card Power Rails</title><link>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-power/</link><pubDate>Sun, 26 Jan 2014 23:26:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-power/</guid><description>Another round of soldering done … this time putting down the power rails on the arithmetic card along with some soldered wire links. This is the last of the soldering for this card - it’s all wire wrapping form hereon in.
The rear of the card now looks like this:
The power rails are very similar to the ones of the logic card completed earlier and they were just as fiddly to complete too … although, that said, I do seem to be developing a bit of a ‘sixth sense’ for how long a wire should be cut without measuring it.</description></item><item><title>ALU Construction: 1-bit Arithmetic Full Construction</title><link>https://relaycomputer.co.uk/posts/2014/01/alu-construction-1-bit-arithmetic-full/</link><pubDate>Tue, 21 Jan 2014 18:25:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/01/alu-construction-1-bit-arithmetic-full/</guid><description>So, as mentioned in my last post this time I’ve put in the wire links and wraps needed to test the first bit of the arithmetic card. With these in place I can make sure everything works as it should before repeating it all eight times over to make the full 8-bit adder.
As a quick reminder here’s the diagram for the 1-bit full adder:
Reproducing this on the arithmetic card gives the following (on the front of the card):</description></item><item><title>ALU Construction: Arithmetic Card Relay Sockets</title><link>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-relay/</link><pubDate>Fri, 17 Jan 2014 23:23:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-relay/</guid><description>It’s always a fiddly job getting the relay sockets soldered in and the ALU arithmetic card proved no exception. With this in mind I’ve been spreading the work out over several mini sessions in accordance with my new post-Xmas lack of patience. Therefore it’s taken me a bit longer than it would otherwise to complete this stage of construction although to be fair I also got distracted with a Nixie clock kit my partner bought me for Christmas … and I ran out of solder (this time though I’ve finally stumped up the cash to buy a 500g reel which should keep me going for a good while). Anyho, after much procrastination all the sockets (and diodes) are now on.</description></item><item><title>ALU Construction: Arithmetic Card Header Pins</title><link>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-header/</link><pubDate>Mon, 06 Jan 2014 22:18:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2014/01/alu-construction-arithmetic-card-header/</guid><description>Following on from the successful construction of the ALU logic card in my last post it’s time to start off the new year with the next ALU card (number 2 of 3 ALU cards in total) … the arithmetic card. As for the logic card I’ll begin by soldering down all the header pins that will be wire wrapped to later on (the LEDs and connectors were already added to this card earlier).</description></item><item><title>ALU Construction: Completed Logic Card Full Test</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-completed-logic-card/</link><pubDate>Wed, 18 Dec 2013 08:26:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-completed-logic-card/</guid><description>The ALU logic card is now finally complete! … well, it is now I’ve popped the last few relays into their sockets. The final card looks like this:
As the old saying goes: a picture paints a thousand words … I’m not sure therefore how many words a video paints but it definitely seems the best way to demonstrate the card in operation. So, with that in mind, I’ve (painstakingly) put the following YouTube video together which gives a walkthrough of the ALU logic card in operation. This one also breaks tradition with my previous videos, where the only sound is the relays clicking, and has a narrative track added courtesy of my very own ‘dulcet’ tones.</description></item><item><title>ALU Construction: Logic Card Wire Wrap 3</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-3/</link><pubDate>Wed, 18 Dec 2013 08:01:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-3/</guid><description>I’m now just one session of wire wrapping away from a completed ALU logic card. The final job is to wire up the gating relays that select one of the five logic results back on to the data bus. Nothing too difficult … just a case of routing the wires in the best way possible to keep things neat and out of the way of the relay sockets.
Keeping with the same wiring colour convention as before the green wires are the results heading out to the data bus, the blue wires are the inputs B and C and the yellow wires are the control lines which activate each of the gating relays as required.</description></item><item><title>ALU Construction: 8-bit Logic Unit Tests</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-8-bit-logic-unit-tests/</link><pubDate>Thu, 12 Dec 2013 19:20:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-8-bit-logic-unit-tests/</guid><description>There’s now enough sockets, solder and wires to test all eight bits of the ALU logic card. This isn’t quite a full test as the gating relays that apply one of the results produced by each bit unit haven’t been wired up yet but there’s enough there to be able to set an input and see the results displayed on the LEDs along the front of the card.
So, it’s time to crack out the relays and pop them in the sockets that make up each logic bit unit. There’s four relays needed in each logic bit unit so thats 32 relays in total and this is what it looks like:</description></item><item><title>ALU Construction: Logic Card Wire Wrap 2</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-2/</link><pubDate>Thu, 12 Dec 2013 18:57:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-2/</guid><description>Continuing on with the wire wrapping for the ALU logic card next up is the input and result links:
Given the limited range of colours I’ve got to choose from (Black, Red, Green, Blue, Yellow) I’ve chosen the following scheme for the wire links:
Black: Internal wire links Red: Power links Blue: Input links Green: Result links Yellow: Control links I’ll no doubt break this convention at some point but in general it should make the cards a little bit easier to fathom out at first glance … especially as the number of wires on the board increases.</description></item><item><title>ALU Construction: Logic Card Wire Wrap 1</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-1/</link><pubDate>Thu, 12 Dec 2013 18:41:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-wrap-1/</guid><description>Finally, with all the soldering now done, it’s time to set about wire wrapping the ALU logic card. First up is the internal connections within each logic bit:
After wire wrapping a new set of wires I always run the multimeter over the board to double check everything is connected as intended. Again though, if there are any mis-wirings it’s trivial to correct — just unwrap the wire and wrap in a new one. There is a bit of skill required to get a ‘perfect’ wrap (where a bit of the insulation is taken around the post followed by nice tight coils above that) and mine are certainly not all perfect but bad ones can always be re-done.</description></item><item><title>ALU Construction: Logic Card Power Rails</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-power-rails/</link><pubDate>Tue, 10 Dec 2013 22:56:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-power-rails/</guid><description>It seems that every time I move on to the next stage of construction on the ALU logic card it’s fiddlier than the stage before it … this stage is no exception. This time I’m adding the power and ground rails that run around the solder side of the board. I’ll start with a picture of how it looks:
The really, really, fiddly bit this time is cutting all those lengths of (solid single core) wire to the required length and then stripping the insulator, bending the ends and soldering down — nothing complex … just fiddly. As part of adding these rails I’ve laid down some additional header pins up the middle of the board to get power to the relay gates as needed. Following usual convention the 12V power rails are in red and the ground rails are in black.</description></item><item><title>Test Board: Construction</title><link>https://relaycomputer.co.uk/posts/2013/12/test-board-construction/</link><pubDate>Tue, 10 Dec 2013 07:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/test-board-construction/</guid><description>I’ve just realised that as I’ve been constructing the first ALU card I’ve not given much thought to how I’ll actually test the card (or other cards for that matter) when complete … this post therefore represents a quick aside to tackle testing.
What I’m looking for is a small board with enough switches on it to drive the various inputs of each card … ideally it’ll be reusable between cards and easy to use. I did originally think of using DIP switches but they’re a bit on the fiddly side so I’ve gone for tactile switches instead — the main problem with these is that they’re non latching but I figure that I won’t need to push more than 10 buttons at a time hopefully.</description></item><item><title>ALU Construction: Logic Card Relay Sockets</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-relay/</link><pubDate>Mon, 09 Dec 2013 07:27:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-relay/</guid><description>The construction of the ALU logic card is coming along nicely but there’s still a lot of soldering ahead to get all the relay sockets down … and this part is the fiddliest bit yet.
The biggest issue I’ve found getting the sockets in place is that unlike the header pins, which tend to stay in place on the board whilst you solder them, the sockets will keep falling out. Usually if I’m soldering components down I’ll work in order of height from shortest to tallest so that when the board is turned over the components have nowhere to go … unfortunately because I started with the LEDs first there’s nothing to hold the sockets in place when soldering. To get around this I’ve had to develop a new skill where I hold the socket in with a finger on one hand and then pick and place a blob of solder with the other hand (remembering which pin I’ve got my finger on to avoid a nasty burn). Needless to say I’ll try and make sure I do things in the ‘right’ order on the other cards ;)</description></item><item><title>ALU Construction: Logic Card Header Pins</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-header-pins/</link><pubDate>Sun, 08 Dec 2013 09:57:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-header-pins/</guid><description>Following on from the successful construction of the first bit on the ALU logic card in my last post it’s now time to start putting together the other 7 bits and the gating circuits (to place one of the logic results on to the data bus). First up is soldering down all the header pins that I’ll wire wrap to.
This part of the construction is certainly repetitive and it’s easy to make mistakes … and actually I made a couple within placing down the first few headers. Suffice to say that it’s a lot easier to solder multi-leg components than it is to unsolder them. Here’s the result of this evenings work:</description></item><item><title>ALU Construction: 1-bit Logic Full Construction</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-1-bit-logic-full/</link><pubDate>Sat, 07 Dec 2013 01:54:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-1-bit-logic-full/</guid><description>So, although I probably should construct the logic card methodically a full stage at a time (solder header pins then sockets then wire wrap) I can’t resist fully assembling a single bit alone to see if/how it works. Here of some pictures of that single bit all soldered in and wired up:
This is the first bit logic unit out of 8 in total and effectively the pattern is repeated 4 times across the board and for 2 rows up the board. One thing I was definitely reminded of when putting this first bit together is how small components on a 0.1 inch pitch actually are and it really is quite fiddly work. Again, the soldering is a bit grizzly where I’ve joined several pads together and couldn’t keep the heat up and solder flowing.</description></item><item><title>ALU Construction: LED Tests</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-led-tests/</link><pubDate>Fri, 06 Dec 2013 20:55:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-led-tests/</guid><description>Following on from my last post I can now test the LEDs that have been soldered and hooked up to the header pins on each of the three ALU cards (Logic, Arithmetic and Control). As promised, here are the videos of said testing:
You might notice I’m prodding around slightly more carefully on the arithmetic and control cards … due to a lack of foresight I’ve ended up with every second header pin being a direct line to 0v … which is not great when the thing I’m holding has 12v at the tip. Luckily my power supply handles short circuits well but even the briefest of sparks can be a tad embarrassing. At some point I’ll chop off the extraneous header pins (as they’re not needed) to ensure I don’t accidentally wire-wrap to one of them later on.</description></item><item><title>ALU Construction: Logic Card Wire Links</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-links/</link><pubDate>Fri, 06 Dec 2013 20:51:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-logic-card-wire-links/</guid><description>Before I can test all of the LEDs laid down so far (to make sure they survived the heat of the soldering iron) I need to add some wire links on the logic card between the LED anodes and the header pins. This isn’t needed on the arithmetic and control cards as they only have a single row of LEDs and so are soldered directly to the header pins but on the logic card, which has two rows of LEDs, the ’negative rail’ sits between the LED anodes and header pins.</description></item><item><title>ALU Construction: LED Header Pins</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-led-header-pins/</link><pubDate>Thu, 05 Dec 2013 21:46:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-led-header-pins/</guid><description>So far, in the construction of the three ALU cards (Logic, Arithmetic and Control) I’ve soldered down the connectors and LEDs. It’s now time to solder in some header pins and join them to the existing connectors and LEDs ready for wire-wrapping later.
You can get proper wire-wrap posts but they’re really expensive for what they are (mainly, I guess, because it’s quite an old-fashioned construction method). I’ve found, though, that header pins do the job just as well but being as they’re not as tall you can only get a maximum of two wraps on each pin. Incidentally, I’ve chosen wire-wrap for most of the cards inner connections as it allows easy and quick modifications and correction of errors (something that can be quite difficult with soldered connections or pretty impossible with etched PCBs). Additionally, I quite like the finished look you get with wire-wrap.</description></item><item><title>Backplane Design and Construction</title><link>https://relaycomputer.co.uk/posts/2013/12/backplane-design-and-construction/</link><pubDate>Tue, 03 Dec 2013 19:27:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/backplane-design-and-construction/</guid><description>Originally when I was thinking about how I’d connect up the various cards of this computer I had ribbon cables in mind. Ribbon cables are straightforward to use and physically flexible which would
allow me to work out how I’d physically arrange the cards later on. However, the more I thought about it the more I liked the idea of using a backplane that the cards would slot in to — a bit like those 19 inch server racks that take CPU cards. This would also give the cards some physical support so I could test several cards together with the whole thing freestanding.</description></item><item><title>ALU Construction: Connectors and LEDs</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-construction-connectors-and-leds/</link><pubDate>Mon, 02 Dec 2013 18:05:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-construction-connectors-and-leds/</guid><description>As promised in my last post it’s finally time to get the soldering iron out and make a start on constructing the three cards that make up the ALU. I’m going start by laying down the connectors and LEDs on each card to make sure I’m happy with the look and feel of things and then I can move on to everything else needed later.
As mentioned in earlier posts I’m basing my construction around 55 x 40 hole pad boards which fit my designs quite nicely at the right sort of size I’m looking to construct at. The connectors are right angled box headers and are simply soldered down to the back of the boards whilst the LEDs run along the front. The LEDs themselves are 3mm 12V types so that an additional resistor is not required (which would make the ‘crammed in’ Logic unit design even more tricky) and to make construction a bit more manageable each LED sits in a right angled holder.</description></item><item><title>ALU Design: Control Unit</title><link>https://relaycomputer.co.uk/posts/2013/12/alu-design-control-unit/</link><pubDate>Sun, 01 Dec 2013 21:21:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/12/alu-design-control-unit/</guid><description>In the last three posts I introduced the design for the 3-to-8 Function Decoder, Zero Detect circuit and the Condition Registers. In this post I’ll put all three of these components together to make up the ALU Control Card. So, placing the relays from the three components onto the card (excluding wire links) we get the following:
ALU Control Card Relays (larger) Unlike the other cards that make up the full ALU (the logic and arithmetic cards) things aren’t quite so tightly packed in this time. Despite this I’ve pushed the relays out towards the edges of the card to leave room for any future ALU control expansion or modifications without requiring an extra card. I’ll be displaying the current state of the 3-to-8 Decoder and Condition Registers with LEDs along the front of the card as with the other cards designed so far. The LEDs are the same 12V ones as before (to save space that would be used by the additional resistors) and follow the same colour code of red for results, yellow for inputs and green for output control signals. Diagram wise the display looks like this:</description></item><item><title>ALU Design: Condition Registers</title><link>https://relaycomputer.co.uk/posts/2013/11/alu-design-condition-registers/</link><pubDate>Sat, 30 Nov 2013 10:12:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/alu-design-condition-registers/</guid><description>This post covers the design of the ALU Condition Registers which along with the 3-to-8 Function Decoder and Zero Detect circuit (both covered in my previous posts) make up the ALU Control Card. There are three Condition Registers in this computer:
Carry: set when a bit is carried in the Arithmetic Unit (which can also indicate arithmetic overflow depending on the interpretation of the numbers being added). Zero: set when the ALU result is zero (all bits are off). Sign: set when the most significant bit is set (which would indicate a negative result for signed values). This condition has no direct meaning for unsigned numbers (other than indicating the number has a value of 128 or more). When the ALU performs an operation the current values of these three conditions are stored in the condition registers so that they can be referred to in other operations. An example of this would be where given two numbers the first is negated and then added to the second … if the two numbers are equal it will result in zero and therefore the Zero condition will be set. Based on this condition register being set you could then branch to a different location in the executing program if desired. That is, for example, if number A and B are equal then go to line C in the program. It’s this ‘branching’ functionality that elevates the computer in terms of power and flexibility and the condition registers are at the heart of this.</description></item><item><title>ALU Design: Zero Detect</title><link>https://relaycomputer.co.uk/posts/2013/11/alu-design-zero-detect/</link><pubDate>Sat, 23 Nov 2013 08:57:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/alu-design-zero-detect/</guid><description>This post covers the design of the Zero Detect circuit which along with the 3-to-8 Function Decoder (covered in my last post) and the Condition Registers (next post) make up the ALU Control Card. The Zero Detect circuit … wait for it … detects when a value is zero. The value in question is taken from the data bus so in effect we’re detecting when no bits are set. The output from this circuit is then passed to the Condition Registers so that the current value can be stored for future operations. The circuit itself is nice and simple:</description></item><item><title>ALU Design: Function Decoder</title><link>https://relaycomputer.co.uk/posts/2013/11/design-function-decoder/</link><pubDate>Wed, 20 Nov 2013 22:18:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/design-function-decoder/</guid><description>This post covers the design of a 3-to-8 Function Decoder which along with the Zero Detect circuit and Condition Registers will all go in to the ALU Control Card. The Decoder takes a 3-bit ALU Function code as its input and activates 1 of 8 control lines accordingly. The function codes are as follows:
Code Operation Description 000 CLR Clear/No Operation 001 ADD B + C 010 INC Increment B 011 AND B AND C 100 OR B OR C 101 XOR B XOR C 110 NOT NOT C 111 SHL Shift Left B The control lines which are fed to the Arithmetic and Logic Units via the Ctrl-Z bus are:</description></item><item><title>ALU Design: 8-bit Arithmetic Unit</title><link>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-arithmetic-unit/</link><pubDate>Sun, 17 Nov 2013 10:43:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-arithmetic-unit/</guid><description>In the last post I introduced the design for the 1-bit Arithmetic Unit. This post covers connecting eight of these units together to make an 8-bit Arithmetic Unit along with result gating and increment functionality.
So, diving straight in, here is what eight of the 1-bit Arithmetic Units look like all together on the usual 55 x 40 hole pad board (excluding wire lines):
8 x 1-bit Arithmetic Unit Relays (larger) As before (with the Logic Unit card) things are a bit on the tight side but everything fits within the 40 hole horizontal confines of the pad board (as if by magic). Each of the 1-bit Arithmetic Units produces a 1-bit output and these need gating back on to the data bus so that the result doesn’t conflict with any other Logic Unit output (or any future outputs from places like the Registers etc). With these additional relays added we get the following (this time including internal wire links in the 1-bit Arithmetic Units and result links between the Arithmetic Units and the gating relays):</description></item><item><title>ALU Design: 1-bit Arithmetic Unit</title><link>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-arithmetic-unit/</link><pubDate>Fri, 15 Nov 2013 22:33:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-arithmetic-unit/</guid><description>This post covers the design of a 1-bit Arithmetic Unit that can add two input bits together (B and C) with carry in and out. Here’s a schematic of the 1-bit Arithmetic Unit (based directly on the one used in the Harry Porter Relay Computer):
The diagram shows two 4PDT relays (just as before for the 1-bit Logic Unit) but this time the second relay has been rotated 180 degrees to make the diagram simpler to draw. B and C are the two 1-bit inputs that drive the relay coils, V is a permanent connection to the power supply and R is the resulting bit. CI is the carry in signal along with its inverted partner ~CI. Similarly CO is the carry output and ~CO is its inverted partner. It’s the use of these regular and inverted carry signals that makes this design so neat … and actually this isn’t one of Harry’s … this design goes back a lot further.</description></item><item><title>ALU Design: 8-bit Logic Unit</title><link>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-logic-unit/</link><pubDate>Wed, 13 Nov 2013 22:42:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-logic-unit/</guid><description>In the last post I introduced the design for a 1-bit Logic Unit. This post covers the design effort to cram 8 of these on to a single pad board complete with connectors, status LEDs and gating relays thereby forming a complete 8-bit Logic Unit.
Sticking with the same diagram style I introduced in the last post here is what 8 of the 1-bit Logic Units look like all crammed on to the 55 x 40 hole pad board (excluding wire links):</description></item><item><title>ALU Design: 1-bit Logic Unit</title><link>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-logic-unit/</link><pubDate>Mon, 11 Nov 2013 23:32:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-logic-unit/</guid><description>This post covers the design of a 1-bit Logic Unit that can produce AND, OR, XOR, NOT and SHL (Shift Left) outputs from two input bits B and C. Here’s a schematic of the 1-bit Logic Unit (based directly on the one used in the Harry Porter Relay Computer):
The diagram shows two 4PDT (4 pole double toggle) relays with the coils of each shown as a striped box at the top. The four double toggle switches are also shown on each relay and the current position of each switch is as when the relay is off. When power is applied to the relay coil all four switches change over simultaneously. The two relays together with all the various connections form the 1-bit Logic Unit. Inputs to the unit are shown with ‘cupped’ line ends: B and C are the two 1-bit inputs; V is a permanent connection to the power supply. Outputs from the unit are shown with an arrowed line end: the outputs AND, OR, XOR, NOT and SHL. Wire joins are shown with a dot (otherwise the wire is passing over but not connecting to another wire) and unused switches on a relay are shown in grey.</description></item><item><title>Relay Rumination</title><link>https://relaycomputer.co.uk/posts/2013/11/relay-rumination/</link><pubDate>Sun, 10 Nov 2013 23:16:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/relay-rumination/</guid><description>If there’s one thing a relay computer needs a lot of it’s … erm … relays (of course) … which happens to be a bit unfortunate as relays, compared to the other parts of the computer, are rather expensive. The Dr Harry Porter Relay Computer (which my computer is based on) uses 415 x 4PDT (4 pole double toggle) relays in total. A comparable part is the Omron MY4-DC12(S) relay and a quick check online with Mouser (other suppliers are available ;) prices them around £3.20 a piece (excluding UK VAT @ 20%) … that’s just under £1600 including VAT which is a bit eye watering for a hobby project (the Harry Porter computer came to just over $5000 in total for everything). Also of note is that the MY4 relays are sized 28 x 21.5 x 36mm … not huge but big enough when you’ve got 415 of them wired together (again, see the Harry Porter computer to see exactly how big these machines can be). Here’s a scaled diagram of the MY4 relay showing the coil and four sets of double toggle contacts.</description></item><item><title>Instruction Set</title><link>https://relaycomputer.co.uk/posts/2013/11/instruction-set/</link><pubDate>Thu, 07 Nov 2013 23:47:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/instruction-set/</guid><description>In the last post I promised to reveal the planned instruction set for the computer and here it is (pdf file).
This should be viewed alongside the architecture diagram which can be found in my previous architecture posts … and to be fair if you’ve been following along through my recent posts then just close your eyes … you’ll probably find it’s been burnt on to your eye balls given the amount of times I’ve posted it ;)</description></item><item><title>Architectural breakdown: Programming and Control 2</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</link><pubDate>Thu, 07 Nov 2013 23:22:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</guid><description>So, the last post didn’t quite wrap up this ‘mini-series’ but hopefully this one will. Continuing on with how the Programming and Control of the computer happens here again, for the last time (really last time), is the architecture I’ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In the last post I covered an example of the steps required to subtract 6 from 10 (with 6 placed in register B and 10 in register C beforehand) and also that each step is represented by an opcode which is placed in the Instruction register so the computer can work out the sequence of actions to take to perform the step. The collection of program steps are stored in the memory along with any data required and so a full program to subtract 6 from 10 would look as follows in memory:</description></item><item><title>Architectural breakdown: Programming and Control</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</link><pubDate>Thu, 07 Nov 2013 21:54:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</guid><description>In this post I’ll wrap up this ‘mini-series’ of trying to explain away the various bits of the architecture that will make up my relay computer project — finally now we come on to Programming and Control of the computer. Here again, for the last time, is the architecture I’ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] With all the various parts of the architecture I’ve discussed so far — the busses, registers, memory and ALU — we have a computer that could be manually operated, albeit laboriously, to perform various tasks. Actually, in fact, this will be the first milestone in the construction of my computer … that I can manually operate what I have built so far just as the computer will itself when it is able to execute programs. Just to give you a feel for exactly how labour intensive even a simple task would be here are the manual steps to subtract 6 from 10:</description></item><item><title>Architectural breakdown: the ALU</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</link><pubDate>Thu, 07 Nov 2013 07:24:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</guid><description>In this post I’ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it’s the Arithmetic Logic Unit (ALU). Here (yet again) is the architecture I’ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] The Arithmetic Logic Unit (ALU) sits at the very heart of the computer and without it you wouldn’t be able to do much at all … you could certainly move data back and forth between the memory and registers but that’d be about it. As you might have guessed from the name it allows the computer to perform arithmetic and logic functions. Some ALUs have a myriad of functionality available but this architecture takes a good balance between simplicity and functionality — the idea being that you can perform more complex functions by using a combination of simpler ones (subtraction can be performed by negating a number then adding it and multiplication can be performed by repeated adding). This does mean that the computer takes longer to do some things, like subtraction and multiplication, but it’s much simpler to construct as a result.</description></item><item><title>Architectural breakdown: Memory</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</link><pubDate>Wed, 06 Nov 2013 20:14:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</guid><description>In this post I’ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it’s the memory. Here again is the architecture I’ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In my last post I wrote about the computer registers, each of which can store a binary value — they’re typically very fast although there’s a fixed number of them (in this computer there’s eight ‘general registers’ A, B, C, D, M1, M2, X and Y). Needless to say we wouldn’t be able to do anything too exciting if we’re limited to only 8 storage slots and that’s where the memory comes in — it’s not as fast (relatively) as the registers but it can hold many, many more values.</description></item><item><title>Architectural breakdown: Buses and Registers</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</link><pubDate>Tue, 05 Nov 2013 19:07:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</guid><description>In this post I’ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it’s buses and registers. Here again is the architecture I’ll be building against (from the Harry Porter Relay Computer):
System Architecture for a Relay Computer[^1] Buses are simply a set of wires that connect up the various parts of a computer. As each wire can carry 1 bit it therefore takes 8 wires to carry 8 bits. In this architecture the data bus is 8 bits wide and the address bus (which I’ll go in to further in the next post on the memory) is 16 bits wide. You can only have a single value on a bus at the same time so any part of the computer that needs to talk to another part has to wait its turn for the bus to become free. It’s worth noting though that because the data and address bus are physically separate you can have different values on each without problem. In the diagram above the data bus is shown as a thick line on the left and the address bus is the thick line on the right. In real life, of course, there would be as many wires as there are bits but to simplify the diagram they’re shown as a single thick line.</description></item><item><title>Architectural breakdown: Binary</title><link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</link><pubDate>Mon, 04 Nov 2013 10:35:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</guid><description>… and it all begins with binary. Binary is a ‘base 2’ numbering system which means it uses the numbers 0 and 1. In contrast humans tend to use decimal (base 10) for their day-to-day numerical needs which, of course, uses the numbers 0 to 9. Binary is particularly suitable for electronics as the numbers 0 and 1 can be represented by a circuit being on (1) or off (0), or more relevantly to this computer, a wire may be carrying power (1) or not (0). If you wanted to be able to carry a single decimal digit (0-9) on a wire you’d need to pull some fancy tricks - perhaps have a different level of power signifying the different digits or send pulses counting up the number. All this gets very complicated though - binary keeps it nice and simple.</description></item><item><title>Architecture isn't just for houses</title><link>https://relaycomputer.co.uk/posts/2013/11/architecture-isnt-just-for-houses/</link><pubDate>Mon, 04 Nov 2013 08:51:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/architecture-isnt-just-for-houses/</guid><description>So, with the scene now set (see previous posts) let’s dive right in and take a look at the system architecture I’ll be building my computer upon … here it is …
System Architecture for a Relay Computer[^1] This is a direct copy of the architecture Dr Harry Porter designed when creating his own relay computer. The architecture has the following features:
8-bit data bus 16-bit address bus 8 x 8-bit general purpose registers (A, B, C, D, M1, M2, X, Y) Registers M1 and M2 combine to make a read only 16-bit register Registers X and Y combine to make a general purpose 16-bit register 8-bit Arithmetic Logic Unit with 3 condition registers (Zero, Carry and Sign) 16-bit jump register (J) 8-bit instruction register 16-bit program counter (PC) with increment unit 32K x 8-bit SRAM I personally think this design has a really good balance of functionality vs complexity. Some ‘home-brew’ architectures may have more registers or extra functions, in the ALU for example, but of course that requires more relays, more construction and extra cost. Equally, some may have less registers and maybe less functions which means although easier to construct the developer writing programs for the machine then has more work to do. A good example of this would be subtraction which could be implemented wholly in the hardware design if desired but would certainly add additional complexity to the ALU. However, you can subtract number B from A but making B negative and then adding A and B together. Now the ALU only needs to be able to negate numbers and add numbers — no special subtract circuit is required. We can even take this a step further by removing the need for a special ’negater’ by performing a bitwise NOT and then incrementing by 1 (due to the special trick computers use to store signed numbers in binary). As you can see though, what was one step for a programmer is now several and as a result the computer will take longer to produce the result.</description></item><item><title>The three Rs</title><link>https://relaycomputer.co.uk/posts/2013/11/the-three-rs/</link><pubDate>Sun, 03 Nov 2013 09:35:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/the-three-rs/</guid><description>It strikes me that when embarking on a project like this there’s three things that are of uttermost importance, the three Rs if you will:
Research, research and research.
There’s a lot to be said for experimentation and working things out but the human race wouldn’t have got very far it didn’t share knowledge and learn from each others mistakes. So naturally, if I want to build my own computer from scratch I should start out by doing lots of reading about how old computers were built.</description></item><item><title>Why?</title><link>https://relaycomputer.co.uk/posts/2013/11/why/</link><pubDate>Sat, 02 Nov 2013 10:46:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/11/why/</guid><description>Whenever I tell people I’m building a relay computer the overwhelming response is … why on Earth would you want to do that?! Or alternatively, as a work colleague delicately put it to me yesterday, if you go to the front of your house there’s a big block of wood that opens — it’s called a door — if you go through it you’ll discover pubs and things. They’ve all got a point though, this project will be very time consuming and I’ve not particularly got a use in mind for the resulting jumble of wires. In fact it’s difficult to think of a real use for it as I’ll be left with something that could be outperformed by a pocket calculator (not a scientific calculator mind, more the kind you might find in a Christmas cracker). So why would I invest lots of time and effort in to making a relay computer? Well, as they say (rather tritely) it’s the journey not the destination.</description></item><item><title>It begins</title><link>https://relaycomputer.co.uk/posts/2013/10/it-begins/</link><pubDate>Thu, 31 Oct 2013 22:21:00 +0000</pubDate><guid>https://relaycomputer.co.uk/posts/2013/10/it-begins/</guid><description>… although being as I’m already a couple of months in on my little project then perhaps that should be ‘it began’.
If I do see this project all the way through to the end, and I’ve plenty of half finished projects littering the place by the way, then I’ll have created an 8 bit computer from scratch. No, not a PC assembled from off the shelf parts — a CPU, motherboard, memory, power supply, case, etc — but made out of a ton of solder, wires, lights, relays, sweat, tears, swearing and money.</description></item><item><title>ALU Summary</title><link>https://relaycomputer.co.uk/pages/alu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/alu/</guid><description>The Arithmetic Logic Unit (ALU) is split into three units (and also three physical cards): the logic unit, the arithmetic unit and the control unit. The logic and arithmetic cards handle 8-bit logic and arithmetic functions respectively. The control unit handles function decoding, zero detection and holds the condition registers.
Details of the design, construction and testing of each unit can be found in the following:</description></item><item><title>Control Summary</title><link>https://relaycomputer.co.uk/pages/control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/control/</guid><description>The computer is controlled by a series of instructions held in memory (a computer program) that are loaded into the instruction register one at a time and executed. The execution of an instruction is performed by running a clock signal through a sequencer which produces a series of pulses. These pulses are then used to operate the control lines of the computer at the right time and in the right order appropriate for the current instruction.</description></item><item><title>Enclosure Summary</title><link>https://relaycomputer.co.uk/pages/enclosure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/enclosure/</guid><description>The enclosure for the computer is based on an aluminium profile frame with laser cut acrylic and plywood panelling. The original design was put together in the excellent SketchUp software before ordering the parts and moving on to the physical construction. The enclosure consists of an upper and lower unit with the lower unit containing all the various cards of the computer and the upper unit primarily acting as a display.</description></item><item><title>Instructions</title><link>https://relaycomputer.co.uk/pages/instructions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/instructions/</guid><description>The computer is controlled by a series of instructions held in memory (a computer program) that are loaded into the instruction register one at a time and executed. Each instruction is formed of an 8-bit ‘op-code’ and falls in to a class of related instructions (identifiable by the leading part of the op-code).
If you’d like to try out the instructions there’s a full simulation of my relay computer available here which also has additional documentation. If you’d like to know even more you can find source code in my GitHub repo as follows:</description></item><item><title>Overview</title><link>https://relaycomputer.co.uk/pages/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/overview/</guid><description>This blog documents my journey in constructing an 8-bit relay computer, from scratch, made from tons of solder, wires, lights, relays, sweat, tears, swearing and money.
The design of the computer is based on the one constructed by Dr. Harry Porter at Portland State University (reproduced on this blog with kind permission) but the construction method is my own and so this blog captures the thoughts, experiences and pitfalls that I encounter along the way.</description></item><item><title>Progress Summary</title><link>https://relaycomputer.co.uk/pages/progress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/progress/</guid><description>Bay W Bay X Bay Y Bay Z Others Deprecated Cards  Complete Backplane W v2 More Info | |  Complete Backplane W Daughterboard</description></item><item><title>RC Assembly Language</title><link>https://relaycomputer.co.uk/pages/assembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/assembly/</guid><description>Although the computer is primarily controlled by a set of 8-bit opcodes these can be tricky to work with when designing more complicated programs. As with many computers we can use a higher-level language which is more readable for a human but then will need converting into 8-bit opcodes for the computer to understand.
I have designed an assembly style language which is made up of a series of mnemonics that each map directly to an equivalent opcode. This makes it easier to create and maintain programs for the computer but still works at the basic hardware level of the computer. This is in contrast to a modern high-level language such as C# where each statement might compile down to a series of opcodes required to perform that action.</description></item><item><title>Registers Summary</title><link>https://relaycomputer.co.uk/pages/registers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/registers/</guid><description>The computer has eight general purpose 8-bit registers named A, B, C, D, M1, M2, X and Y. Although each can be used generally some of the registers have additional specific uses. Register B and C feed the ALU inputs, M1 and M2 form a 16-bit memory pointer (M) and X and Y form a 16-bit memory pointer (XY) typically used to store a return address when performing jumps.
In addition to the general purpose registers there are five special registers named J1, J2, the instruction register, the program counter and the ALU condition code register. J1 and J2 form a 16-bit memory pointer (J) typically used to store a jump address. J1 and J2 cannot be selected and J cannot be loaded hence why they are not therefore classed as general purpose. The instruction register holds the current instruction to be executed and can only be loaded. The program counter can only be loaded and selected from/to the address bus.</description></item><item><title>UI Summary</title><link>https://relaycomputer.co.uk/pages/ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://relaycomputer.co.uk/pages/ui/</guid><description>The computer’s user interface is comprised of two display cards (A and B) and then a row of data and control switches. Display A shows the state of the various control signals and allows the user to manually set those signals when the computer is placed in the ‘diagnostic mode’. Display B likewise shows other control signals but these are read only. Additionally Display B also shows the state of the data and address busses and shows the current consumption of the computer. The two display cards are wired out to the various busses on the display distribution card.</description></item></channel></rss>