<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>aux-ctrl on Relay Computer</title>
    <link>https://relaycomputer.co.uk/cards/aux-ctrl/</link>
    <description>Recent content in aux-ctrl on Relay Computer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 27 Mar 2018 22:07:00 +0000</lastBuildDate><atom:link href="https://relaycomputer.co.uk/cards/aux-ctrl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Auxiliary Control Construction</title>
      <link>https://relaycomputer.co.uk/posts/2018/03/auxiliary-control-construction/</link>
      <pubDate>Tue, 27 Mar 2018 22:07:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/03/auxiliary-control-construction/</guid>
      <description>In my last three posts I covered the design of the auxiliary control unit which will ease entering and inspecting programs in the computer’s memory. With the design ‘in the bag’ it’s time to get constructing although this time we’re not starting with a blank card …
Currently the auxiliary card has the gating relays along the bottom which connect the primary switches to either the address or data bus as required.</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 3 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</link>
      <pubDate>Wed, 07 Feb 2018 22:07:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</guid>
      <description>This is the last post in a mini-series of three covering the design of the auxiliary control unit which will ease entering and inspecting programs in the computer&amp;rsquo;s memory. In my last post I covered the design of the auxiliary clock which resulted in the following schematic:
Auxiliary Clock Schematic (larger) &amp;hellip; which generates the following timing pulses &amp;hellip;
This post covers the last part of the puzzle which is designing the control logic that will take the pulses above and use them to drive the appropriate control lines at the right time according to the instruction the user requested as follows:</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 2 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</link>
      <pubDate>Mon, 29 Jan 2018 22:12:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</guid>
      <description>In my last post I made a start on the auxiliary control design which once completed will make it much easier to load instructions in to memory - effectively it&amp;rsquo;s a computer within a computer. If you haven&amp;rsquo;t read my previous post then it&amp;rsquo;s definitely worth doing so as this post picks up where that one left off. As a reminder though we&amp;rsquo;re looking to perform the following operations:
Auxiliary Control Operations Timing (larger) &amp;hellip; which can be derived from the following pulses &amp;hellip;</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 1 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</link>
      <pubDate>Wed, 24 Jan 2018 21:24:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</guid>
      <description>My relay computer is now at the point where it can execute a program in memory without assistance. In order to do that though, of course, the program needs to be loaded into memory in the first place and at the moment that&amp;rsquo;s a bit of a pain. For each line of the program you need to set the primary data switches to match the desired &amp;lsquo;opcode&amp;rsquo;, gate the switches to the data bus, gate the program counter to the address bus, gate the data bus to the memory and then write to the memory - that&amp;rsquo;s four buttons to press simultaneously.</description>
    </item>
    
    <item>
      <title>User Interface Design: Instruction, Clock and Sequencer</title>
      <link>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</link>
      <pubDate>Wed, 08 Apr 2015 23:19:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</guid>
      <description>Over my last seven posts I&amp;rsquo;ve been slowly putting together the card designs so that the computer will be able to operate the MOV-8, ALU and SETAB instructions. The final step in this series is to update the designs for the two display cards along with the main switches to work with the new cards added recently.
Diving straight in here is the latest version of the Display A design:</description>
    </item>
    
    <item>
      <title>User Interface: Data Switches</title>
      <link>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</link>
      <pubDate>Sat, 05 Jul 2014 09:40:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</guid>
      <description>Now I&amp;rsquo;ve got a fully working ALU and four registers completed I want to take a short break from card building and turn my attention to making it easier to interact with the computer. Currently I&amp;rsquo;m controlling the computer via a set of DIP switches which is incredibly fiddly so it&amp;rsquo;s time to construct something &amp;lsquo;chunkier&amp;rsquo;.
The switches I&amp;rsquo;m going to concentrate on first are the primary data switches which permit values to be placed on the data bus.</description>
    </item>
    
  </channel>
</rss>
