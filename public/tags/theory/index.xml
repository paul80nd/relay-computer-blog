<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>theory on Relay Computer</title>
    <link>https://relaycomputer.co.uk/tags/theory/</link>
    <description>Recent content in theory on Relay Computer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 06 Oct 2019 01:00:00 +0000</lastBuildDate><atom:link href="https://relaycomputer.co.uk/tags/theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Branching: Opcode Timing</title>
      <link>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</link>
      <pubDate>Sun, 06 Oct 2019 01:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</guid>
      <description>In my last post I covered the design for the GOTO opcode which will enable my relay computer to perform branching, loops and so on. Here&amp;rsquo;s where I got to last time:
Branch/Call &amp;amp; 16-bit Load Immediate GOTO 24 1 1 d s c z n x h h h h h h h h l l l l l l l l d = destination register (0-M, 1-J)
s = 1 = load PC if sign bit is set (if negative); 0 = ignore sign bit</description>
    </item>
    
    <item>
      <title>Branching: Opcode Design</title>
      <link>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</link>
      <pubDate>Mon, 23 Sep 2019 01:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</guid>
      <description>There&amp;rsquo;s been a common theme recently in the comments on my YouTube videos &amp;hellip; people are ready to see my relay computer gain the power of branching and become a &amp;lsquo;proper&amp;rsquo; computer &amp;hellip; and that&amp;rsquo;s fair enough because that&amp;rsquo;s the point where the computer can do way more interesting things and run more complicated programs. Originally I was going to add new instructions to the computer in order of complexity but I don&amp;rsquo;t want to keep you (or I) waiting for the &amp;lsquo;main event&amp;rsquo; any longer so it&amp;rsquo;s time to start designing the most complicated of all instruction classes &amp;hellip; the &amp;lsquo;GOTO&amp;rsquo;.</description>
    </item>
    
    <item>
      <title>The problem with memory</title>
      <link>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</link>
      <pubDate>Fri, 18 Aug 2017 22:58:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</guid>
      <description>It&amp;rsquo;s time, at last, to start looking at the design for the computer&amp;rsquo;s memory and this is a bit of a game changer as it&amp;rsquo;s the final part of the jigsaw that lets the computer run a program. However, it&amp;rsquo;s also the part of the computer that leaves me in a bit of a quandary.
The problem with memory is that typically you need quite a lot of it and that&amp;rsquo;s something that doesn&amp;rsquo;t come easy with relays.</description>
    </item>
    
    <item>
      <title>Sequencing &amp; Control Design: Overview</title>
      <link>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</link>
      <pubDate>Fri, 19 Sep 2014 23:27:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</guid>
      <description>I&amp;rsquo;ve now got my computer to a state where I can perform ALU operations and push values around the four registers by manually operating the various control lines. It&amp;rsquo;s time to move things on a bit now and work towards getting the computer to the point where given a specific instruction/op-code it can operate the control lines itself without further input from the user. Eventually the computer will be given a list of instructions to perform which it&amp;rsquo;ll work through step by step but for now the next milestone is to automate the operation of a single instruction.</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Programming and Control 2</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</link>
      <pubDate>Thu, 07 Nov 2013 23:22:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</guid>
      <description>So, the last post didn&amp;rsquo;t quite wrap up this &amp;lsquo;mini-series&amp;rsquo; but hopefully this one will. Continuing on with how the Programming and Control of the computer happens here again, for the last time (really last time), is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In the last post I covered an example of the steps required to subtract 6 from 10 (with 6 placed in register B and 10 in register C beforehand) and also that each step is represented by an opcode which is placed in the Instruction register so the computer can work out the sequence of actions to take to perform the step.</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Programming and Control</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</link>
      <pubDate>Thu, 07 Nov 2013 21:54:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</guid>
      <description>In this post I&amp;rsquo;ll wrap up this &amp;lsquo;mini-series&amp;rsquo; of trying to explain away the various bits of the architecture that will make up my relay computer project — finally now we come on to Programming and Control of the computer. Here again, for the last time, is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] With all the various parts of the architecture I&amp;rsquo;ve discussed so far — the busses, registers, memory and ALU — we have a computer that could be manually operated, albeit laboriously, to perform various tasks.</description>
    </item>
    
    <item>
      <title>Architectural breakdown: the ALU</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</link>
      <pubDate>Thu, 07 Nov 2013 07:24:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s the Arithmetic Logic Unit (ALU). Here (yet again) is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] The Arithmetic Logic Unit (ALU) sits at the very heart of the computer and without it you wouldn&amp;rsquo;t be able to do much at all &amp;hellip; you could certainly move data back and forth between the memory and registers but that&amp;rsquo;d be about it.</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Memory</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</link>
      <pubDate>Wed, 06 Nov 2013 20:14:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s the memory. Here again is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In my last post I wrote about the computer registers, each of which can store a binary value — they&amp;rsquo;re typically very fast although there&amp;rsquo;s a fixed number of them (in this computer there&amp;rsquo;s eight &amp;lsquo;general registers&amp;rsquo; A, B, C, D, M1, M2, X and Y).</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Buses and Registers</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</link>
      <pubDate>Tue, 05 Nov 2013 19:07:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s buses and registers. Here again is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer):
System Architecture for a Relay Computer[^1] Buses are simply a set of wires that connect up the various parts of a computer. As each wire can carry 1 bit it therefore takes 8 wires to carry 8 bits.</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Binary</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</link>
      <pubDate>Mon, 04 Nov 2013 10:35:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</guid>
      <description>&amp;hellip; and it all begins with binary. Binary is a &amp;lsquo;base 2&amp;rsquo; numbering system which means it uses the numbers 0 and 1. In contrast humans tend to use decimal (base 10) for their day-to-day numerical needs which, of course, uses the numbers 0 to 9. Binary is particularly suitable for electronics as the numbers 0 and 1 can be represented by a circuit being on (1) or off (0), or more relevantly to this computer, a wire may be carrying power (1) or not (0).</description>
    </item>
    
  </channel>
</rss>
