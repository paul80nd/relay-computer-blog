<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Relay Computer</title>
    <link>https://relaycomputer.co.uk/tags/architecture/</link>
    <description>Recent content in Architecture on Relay Computer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 24 Jul 2016 22:13:00 +0100</lastBuildDate><atom:link href="https://relaycomputer.co.uk/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Yet another diversion</title>
      <link>https://relaycomputer.co.uk/posts/2016/07/yet-another-diversion/</link>
      <pubDate>Sun, 24 Jul 2016 22:13:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2016/07/yet-another-diversion/</guid>
      <description>It&amp;rsquo;s been a bit quiet on the relay computer front again for a while &amp;hellip; well it is summer after all and there&amp;rsquo;s no point staying inside the house tending to my hobbies when I can be running around outside getting sunburnt. Of course though, this is the UK and summer consists mostly of rain (as do most of the other seasons here) so what other excuse do I have for not posting in ages?
</description>
    </item>
    
    <item>
      <title>Instruction Set</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/instruction-set/</link>
      <pubDate>Thu, 07 Nov 2013 23:47:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/instruction-set/</guid>
      <description>In the last post I promised to reveal the planned instruction set for the computer and here it is (pdf file).
This should be viewed alongside the architecture diagram which can be found in my previous architecture posts &amp;hellip; and to be fair if you&amp;rsquo;ve been following along through my recent posts then just close your eyes &amp;hellip; you&amp;rsquo;ll probably find it&amp;rsquo;s been burnt on to your eye balls given the amount of times I&amp;rsquo;ve posted it ;)
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Programming and Control 2</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</link>
      <pubDate>Thu, 07 Nov 2013 23:22:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and_7/</guid>
      <description>So, the last post didn&amp;rsquo;t quite wrap up this &amp;lsquo;mini-series&amp;rsquo; but hopefully this one will. Continuing on with how the Programming and Control of the computer happens here again, for the last time (really last time), is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In the last post I covered an example of the steps required to subtract 6 from 10 (with 6 placed in register B and 10 in register C beforehand) and also that each step is represented by an opcode which is placed in the Instruction register so the computer can work out the sequence of actions to take to perform the step. The collection of program steps are stored in the memory along with any data required and so a full program to subtract 6 from 10 would look as follows in memory:
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Programming and Control</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</link>
      <pubDate>Thu, 07 Nov 2013 21:54:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-programming-and/</guid>
      <description>In this post I&amp;rsquo;ll wrap up this &amp;lsquo;mini-series&amp;rsquo; of trying to explain away the various bits of the architecture that will make up my relay computer project — finally now we come on to Programming and Control of the computer. Here again, for the last time, is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] With all the various parts of the architecture I&amp;rsquo;ve discussed so far — the busses, registers, memory and ALU — we have a computer that could be manually operated, albeit laboriously, to perform various tasks. Actually, in fact, this will be the first milestone in the construction of my computer &amp;hellip; that I can manually operate what I have built so far just as the computer will itself when it is able to execute programs. Just to give you a feel for exactly how labour intensive even a simple task would be here are the manual steps to subtract 6 from 10:
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: the ALU</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</link>
      <pubDate>Thu, 07 Nov 2013 07:24:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-alu/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s the Arithmetic Logic Unit (ALU). Here (yet again) is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] The Arithmetic Logic Unit (ALU) sits at the very heart of the computer and without it you wouldn&amp;rsquo;t be able to do much at all &amp;hellip; you could certainly move data back and forth between the memory and registers but that&amp;rsquo;d be about it. As you might have guessed from the name it allows the computer to perform arithmetic and logic functions. Some ALUs have a myriad of functionality available but this architecture takes a good balance between simplicity and functionality — the idea being that you can perform more complex functions by using a combination of simpler ones (subtraction can be performed by negating a number then adding it and multiplication can be performed by repeated adding). This does mean that the computer takes longer to do some things, like subtraction and multiplication, but it&amp;rsquo;s much simpler to construct as a result.
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Memory</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</link>
      <pubDate>Wed, 06 Nov 2013 20:14:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-memory/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s the memory. Here again is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer)
System Architecture for a Relay Computer[^1] In my last post I wrote about the computer registers, each of which can store a binary value — they&amp;rsquo;re typically very fast although there&amp;rsquo;s a fixed number of them (in this computer there&amp;rsquo;s eight &amp;lsquo;general registers&amp;rsquo; A, B, C, D, M1, M2, X and Y). Needless to say we wouldn&amp;rsquo;t be able to do anything too exciting if we&amp;rsquo;re limited to only 8 storage slots and that&amp;rsquo;s where the memory comes in — it&amp;rsquo;s not as fast (relatively) as the registers but it can hold many, many more values.
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Buses and Registers</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</link>
      <pubDate>Tue, 05 Nov 2013 19:07:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-buses-and/</guid>
      <description>In this post I&amp;rsquo;ll continue to try and explain away the various bits of the architecture that will make up my relay computer project — this time it&amp;rsquo;s buses and registers. Here again is the architecture I&amp;rsquo;ll be building against (from the Harry Porter Relay Computer):
System Architecture for a Relay Computer[^1] Buses are simply a set of wires that connect up the various parts of a computer. As each wire can carry 1 bit it therefore takes 8 wires to carry 8 bits. In this architecture the data bus is 8 bits wide and the address bus (which I&amp;rsquo;ll go in to further in the next post on the memory) is 16 bits wide. You can only have a single value on a bus at the same time so any part of the computer that needs to talk to another part has to wait its turn for the bus to become free. It&amp;rsquo;s worth noting though that because the data and address bus are physically separate you can have different values on each without problem. In the diagram above the data bus is shown as a thick line on the left and the address bus is the thick line on the right. In real life, of course, there would be as many wires as there are bits but to simplify the diagram they&amp;rsquo;re shown as a single thick line.
</description>
    </item>
    
    <item>
      <title>Architectural breakdown: Binary</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</link>
      <pubDate>Mon, 04 Nov 2013 10:35:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architectural-breakdown-binary/</guid>
      <description>&amp;hellip; and it all begins with binary. Binary is a &amp;lsquo;base 2&amp;rsquo; numbering system which means it uses the numbers 0 and 1. In contrast humans tend to use decimal (base 10) for their day-to-day numerical needs which, of course, uses the numbers 0 to 9. Binary is particularly suitable for electronics as the numbers 0 and 1 can be represented by a circuit being on (1) or off (0), or more relevantly to this computer, a wire may be carrying power (1) or not (0). If you wanted to be able to carry a single decimal digit (0-9) on a wire you&amp;rsquo;d need to pull some fancy tricks - perhaps have a different level of power signifying the different digits or send pulses counting up the number. All this gets very complicated though - binary keeps it nice and simple.
</description>
    </item>
    
    <item>
      <title>Architecture isn&#39;t just for houses</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/architecture-isnt-just-for-houses/</link>
      <pubDate>Mon, 04 Nov 2013 08:51:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/architecture-isnt-just-for-houses/</guid>
      <description>So, with the scene now set (see previous posts) let&amp;rsquo;s dive right in and take a look at the system architecture I&amp;rsquo;ll be building my computer upon &amp;hellip; here it is &amp;hellip;
System Architecture for a Relay Computer[^1] This is a direct copy of the architecture Dr Harry Porter designed when creating his own relay computer. The architecture has the following features:
8-bit data bus 16-bit address bus 8 x 8-bit general purpose registers (A, B, C, D, M1, M2, X, Y) Registers M1 and M2 combine to make a read only 16-bit register Registers X and Y combine to make a general purpose 16-bit register 8-bit Arithmetic Logic Unit with 3 condition registers (Zero, Carry and Sign) 16-bit jump register (J) 8-bit instruction register 16-bit program counter (PC) with increment unit 32K x 8-bit SRAM I personally think this design has a really good balance of functionality vs complexity. Some &amp;lsquo;home-brew&amp;rsquo; architectures may have more registers or extra functions, in the ALU for example, but of course that requires more relays, more construction and extra cost. Equally, some may have less registers and maybe less functions which means although easier to construct the developer writing programs for the machine then has more work to do. A good example of this would be subtraction which could be implemented wholly in the hardware design if desired but would certainly add additional complexity to the ALU. However, you can subtract number B from A but making B negative and then adding A and B together. Now the ALU only needs to be able to negate numbers and add numbers — no special subtract circuit is required. We can even take this a step further by removing the need for a special &amp;rsquo;negater&amp;rsquo; by performing a bitwise NOT and then incrementing by 1 (due to the special trick computers use to store signed numbers in binary). As you can see though, what was one step for a programmer is now several and as a result the computer will take longer to produce the result.
</description>
    </item>
    
  </channel>
</rss>
