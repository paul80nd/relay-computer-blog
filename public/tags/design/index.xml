<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Relay Computer</title>
    <link>https://relaycomputer.co.uk/tags/design/</link>
    <description>Recent content in Design on Relay Computer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Mon, 05 Dec 2022 06:00:00 +0000</lastBuildDate><atom:link href="https://relaycomputer.co.uk/tags/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Controller Design: MOV8, MOV16 &amp; MISC Instructions</title>
      <link>https://relaycomputer.co.uk/posts/2022/12/controller-mov8-mov16-misc-design/</link>
      <pubDate>Mon, 05 Dec 2022 06:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2022/12/controller-mov8-mov16-misc-design/</guid>
      <description>Way back in 2019 I discussed how you can&amp;rsquo;t &amp;lsquo;half design a PCB&amp;rsquo; and that, as a result, my controller cards already have all the required functionality laid down &amp;hellip; I just haven&amp;rsquo;t explained how those &amp;lsquo;missing&amp;rsquo; bits of functionality work in this blog yet.
To ensure I was &amp;lsquo;playing fair&amp;rsquo; when constructing the controller I only soldered in the relays for the instructions I&amp;rsquo;d explained in this blog so far. Well, in my Relay Clock Series you may have noticed in the final episode I decided to solder the remaining relays in on the lower controller card meaning &amp;hellip; the MOV8, MOV16 and MISC instruction classes are now complete and pretty much raring to go &amp;hellip; which means I should probably get on with explaining them.
</description>
    </item>
    
    <item>
      <title>Tick Tock</title>
      <link>https://relaycomputer.co.uk/posts/2022/11/tick-tock/</link>
      <pubDate>Sun, 20 Nov 2022 11:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2022/11/tick-tock/</guid>
      <description>Well, what a journey that&amp;rsquo;s been then &amp;hellip; I started work on a clock for my relay computer back in May 2020 and today (20th Nov 2022) this post marks the end of it. Needless to say that global pandemic got in the way a bit and hampered progress but I also, well, kind of fell out of love with my relay computer for a bit.
Like most of my hobbies I can blow &amp;lsquo;hot and cold&amp;rsquo; but given I also set myself the challenge of closely detailing progress in a series of videos (all 16 of them) it was leaning me towards the &amp;lsquo;cold&amp;rsquo; rather than the &amp;lsquo;hot&amp;rsquo;. Anyho, we&amp;rsquo;re here now and the computer finally has its clock and all card bays of the computer now have something in them.
</description>
    </item>
    
    <item>
      <title>Back to Backplanes</title>
      <link>https://relaycomputer.co.uk/posts/2022/11/back-to-backplanes/</link>
      <pubDate>Sat, 05 Nov 2022 11:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2022/11/back-to-backplanes/</guid>
      <description>Quite a while ago I decided to give up on the tedious wire wrap technique for building my cards. Although it was certainly more authentic and in-keeping with my computer&amp;rsquo;s theme it was massively time consuming for me and was ultimately putting me off making progress on construction.
Another problem with my previous construction methods was creating monstrosities like this:
This is the &amp;lsquo;W&amp;rsquo; backplane connector which connects five of the &amp;lsquo;W&amp;rsquo; type cards together &amp;hellip; and its as precarious as it looks and over time I&amp;rsquo;ve found the ribbon cable on the back of these backplanes are getting a bit temperamental. If left well alone they&amp;rsquo;re fine but any knocks or pokes and whole lines can become disconnected. To solve this I made my own PCB for the Y backplane removing the need for the ribbon cable:
</description>
    </item>
    
    <item>
      <title>Decoder Design: Schematic &amp; PCBs</title>
      <link>https://relaycomputer.co.uk/posts/2019/12/decoder-design-pcb/</link>
      <pubDate>Sun, 22 Dec 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/12/decoder-design-pcb/</guid>
      <description>I&amp;rsquo;ve almost got everything I need now to get my relay computer to do branching. The hard work of designing and constructing the sequencer and controller units is complete and both units can perform a GOTO operation. The only problem now is the decoder card doesn&amp;rsquo;t understand what a GOTO instruction looks like and so can&amp;rsquo;t tell the controller unit to perform a GOTO. That&amp;rsquo;s easily fixed though as the decoder is one of the simplest cards in my computer.
</description>
    </item>
    
    <item>
      <title>Controller Design: Schematic &amp; PCBs</title>
      <link>https://relaycomputer.co.uk/posts/2019/12/controller-design-pcb/</link>
      <pubDate>Fri, 20 Dec 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/12/controller-design-pcb/</guid>
      <description>In my last couple of posts I finalised the controller schematic designs for the ALU, SETAB, MOV8 and GOTO class of instructions. Now it&amp;rsquo;s time to bring all those schematics together and design the two controller PCBs. As with the sequencer, the controller is spread over two interconnected cards and I&amp;rsquo;ll need to decide what&amp;rsquo;s going on the upper card and what will go on the lower card.
It&amp;rsquo;s also worth mentioning at this point that the schematics and PCB designs I&amp;rsquo;m about to share will have some instruction classes laid out that I haven&amp;rsquo;t covered yet in this blog. This is because you can&amp;rsquo;t &amp;lsquo;half design&amp;rsquo; a PCB. I&amp;rsquo;ll cover these new instructions in more detail in the future but suffice to say that they&amp;rsquo;ll definitely be needed. In choosing what will go on which card I follow a similar rule to what I did on the sequencer and go by the number of relays required in each functional group. In the end I&amp;rsquo;ve gone for putting GOTO and MOV8/MOV16/MISC on the lower card and everything else on the upper card.
</description>
    </item>
    
    <item>
      <title>Controller Design: ALU, MOV8 &amp; SETAB Instructions</title>
      <link>https://relaycomputer.co.uk/posts/2019/12/controller-alu-mov8-setab-design/</link>
      <pubDate>Sat, 07 Dec 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/12/controller-alu-mov8-setab-design/</guid>
      <description>In my last post I covered off the controller design for the GOTO instruction. Being as I&amp;rsquo;ve decided to implement the controller on a new set of PCB cards I need to transfer over the existing ALU, MOV8 &amp;amp; SETAB instructions to the new controller design. At the relay level nothing really changes so I&amp;rsquo;ll just quickly recap the timing and implementations here using the new schematic style and then in my next post I can move on to putting the full controller schematic and PCB design together.
</description>
    </item>
    
    <item>
      <title>Controller Design: GOTO Instruction</title>
      <link>https://relaycomputer.co.uk/posts/2019/11/controller-goto-design/</link>
      <pubDate>Sat, 30 Nov 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/11/controller-goto-design/</guid>
      <description>With the sequencer now designed and constructed I&amp;rsquo;m much closer to getting branching working on my relay computer. The next hurdle is updating the controller cards so that they can fire the appropriate control lines at the right time as directed by the sequencer pulses. As a reminder here&amp;rsquo;s the GOTO instruction itself:
Branch/Call &amp;amp; 16-bit Load Immediate GOTO 24 1 1 d s c z n x h h h h h h h h l l l l l l l l d = destination register (0-M, 1-J)
s = 1 = load PC if sign bit is set (if negative); 0 = ignore sign bit
c = 1 = load PC if carry bit is set (if carry); 0 = ignore carry bit
z = 1 = load PC if zero bit set (if result is zero); 0 = ignore if zero bit set
n = 1 = load PC if zero bit clear (if result is not zero); 0 = ignore if zero bit clear
x = 1 = copy PC to XY; 0 = no copy
hhhhhhhh = address high byte (to set in M2/J2)
llllllll = address low byte (to set in M1/J1) &amp;hellip; and here&amp;rsquo;s the associated timing chart to be implemented &amp;hellip;
</description>
    </item>
    
    <item>
      <title>Sequencer Design: Schematic &amp; PCBs</title>
      <link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pcb/</link>
      <pubDate>Mon, 11 Nov 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pcb/</guid>
      <description>I&amp;rsquo;ve got the designs for the 24-cycle FSM and pulse distribution in place so all that&amp;rsquo;s left for the sequencer is to bring the schematics together and then design the PCBs &amp;hellip; and yup, that&amp;rsquo;s PCBs plural as this is going to be another part of the computer that is complicated enough to need spreading over two interconnected cards. The way I can tell this is a &amp;rsquo;two card job&amp;rsquo; is purely down to the number of relays I&amp;rsquo;ve used. In this case the total comes to 60 and if you&amp;rsquo;re really packing them in (6 rows of 8 relays) you can just about get away with a maximum of 48 per card.
</description>
    </item>
    
    <item>
      <title>Sequencer Design: Pulse Distribution</title>
      <link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pulse-dist/</link>
      <pubDate>Sat, 02 Nov 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-pulse-dist/</guid>
      <description>In my last post I extended the 8-cycle FSM (finite state machine) design all the way up to 24-cycles so that we can run longer and more complicated instructions. In this case we&amp;rsquo;re looking to implement the GOTO instruction so that the computer can perform branching.
As a recap here&amp;rsquo;s the outputs from the newly designed FSM:
24-cycle FSM Outputs (larger) &amp;hellip; and here&amp;rsquo;s the timing chart that we&amp;rsquo;re trying to obtain:
</description>
    </item>
    
    <item>
      <title>Sequencer Design: 24-cycle FSM</title>
      <link>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-24-cycle-fsm/</link>
      <pubDate>Fri, 01 Nov 2019 03:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/11/sequencer-design-24-cycle-fsm/</guid>
      <description>Recently I&amp;rsquo;ve been looking at what&amp;rsquo;s needed to implement branching in my computer (the upcoming GOTO class of instructions). In my last post I covered the timing chart for the GOTO class which is repeated below:
GOTO opcode timing chart (larger) To achieve this timing I&amp;rsquo;ll need a sequencer that can &amp;lsquo;count&amp;rsquo; up to 24 (currently it only goes up to 8). Actually none of this is too difficult as counting beyond 8 more-or-less repeats the same pattern of relays. If you&amp;rsquo;re not familiar with how the current 8 cycle sequencer works then it&amp;rsquo;s well worth reading the post on that which goes in to more detail around how the FSM (finite state machine) works.
</description>
    </item>
    
    <item>
      <title>Branching: Opcode Timing</title>
      <link>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</link>
      <pubDate>Sun, 06 Oct 2019 01:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/10/branching-opcode-timing/</guid>
      <description>In my last post I covered the design for the GOTO opcode which will enable my relay computer to perform branching, loops and so on. Here&amp;rsquo;s where I got to last time:
Branch/Call &amp;amp; 16-bit Load Immediate GOTO 24 1 1 d s c z n x h h h h h h h h l l l l l l l l d = destination register (0-M, 1-J)
s = 1 = load PC if sign bit is set (if negative); 0 = ignore sign bit
c = 1 = load PC if carry bit is set (if carry); 0 = ignore carry bit
z = 1 = load PC if zero bit set (if result is zero); 0 = ignore if zero bit set
n = 1 = load PC if zero bit clear (if result is not zero); 0 = ignore if zero bit clear
x = 1 = copy PC to XY; 0 = no copy
hhhhhhhh = address high byte (to set in M2/J2)
llllllll = address low byte (to set in M1/J1) The opcode can also be drawn in diagram form as follows:
</description>
    </item>
    
    <item>
      <title>Branching: Opcode Design</title>
      <link>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</link>
      <pubDate>Mon, 23 Sep 2019 01:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/09/branching-opcode-design/</guid>
      <description>There&amp;rsquo;s been a common theme recently in the comments on my YouTube videos &amp;hellip; people are ready to see my relay computer gain the power of branching and become a &amp;lsquo;proper&amp;rsquo; computer &amp;hellip; and that&amp;rsquo;s fair enough because that&amp;rsquo;s the point where the computer can do way more interesting things and run more complicated programs. Originally I was going to add new instructions to the computer in order of complexity but I don&amp;rsquo;t want to keep you (or I) waiting for the &amp;lsquo;main event&amp;rsquo; any longer so it&amp;rsquo;s time to start designing the most complicated of all instruction classes &amp;hellip; the &amp;lsquo;GOTO&amp;rsquo;.
</description>
    </item>
    
    <item>
      <title>16-bit Register PCB Design</title>
      <link>https://relaycomputer.co.uk/posts/2019/08/16bit-register-pcb-design/</link>
      <pubDate>Fri, 09 Aug 2019 01:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/08/16bit-register-pcb-design/</guid>
      <description>It&amp;rsquo;s time for the oddly therapeutic part of designing a PCB &amp;hellip; laying out the board. In my last post I covered the schematic design and so we now have all the components required for a 16-bit register captured in my design program of choice (EasyEDA) along with how each component is connected to everything else. The next step is to generate a PCB layout from that schematic &amp;hellip; and I say &amp;lsquo;generate&amp;rsquo; which perhaps makes it sound like it&amp;rsquo;s a &amp;lsquo;click of a button&amp;rsquo; type thing &amp;hellip; well, clicking the &amp;lsquo;create PCB&amp;rsquo; button results in this:
</description>
    </item>
    
    <item>
      <title>16-bit Register Design</title>
      <link>https://relaycomputer.co.uk/posts/2019/07/16bit-register-design/</link>
      <pubDate>Mon, 15 Jul 2019 11:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/07/16bit-register-design/</guid>
      <description>In my last couple of posts I&amp;rsquo;ve been building up to a change of approach in how I&amp;rsquo;m making the cards in my computer. This is mainly because I can&amp;rsquo;t face the monotony of hand building the upcoming register cards (which I&amp;rsquo;ll need three of so it&amp;rsquo;s triple the procrastination holding me back). The obvious solution to all of this is to create a Printed Circuit Board (PCB) which will cut out most of the trickier soldering and pretty much all the repetitive wirewrap &amp;hellip; and that looked like the way to go until I had a go at hand crafting a simplified PCB for the Y backplane and I realised it&amp;rsquo;s not as easy as it might otherwise appear.
</description>
    </item>
    
    <item>
      <title>A change of approach</title>
      <link>https://relaycomputer.co.uk/posts/2019/01/change-of-approach/</link>
      <pubDate>Mon, 14 Jan 2019 11:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2019/01/change-of-approach/</guid>
      <description>In my last post I touched on how the repetitive nature of making register cards has been putting me off progressing my relay computer. If you&amp;rsquo;ve followed my blog (over the years) you&amp;rsquo;ll have witnessed the construction of the general purpose registers A, B, C and D along with the specialised registers in the incrementer and program counter. Each register card follows the same construction pattern: solder down LEDs, solder down relay sockets, solder down wire wrap posts, solder ground and power lines, wire wrap, wire wrap, wire wrap, wire wrap, etc, etc, insert relays in sockets. Tedious, tedious, tedious.
</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 3 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</link>
      <pubDate>Wed, 07 Feb 2018 22:07:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/02/auxiliary-control-design-part-3-of-3/</guid>
      <description>This is the last post in a mini-series of three covering the design of the auxiliary control unit which will ease entering and inspecting programs in the computer&amp;rsquo;s memory. In my last post I covered the design of the auxiliary clock which resulted in the following schematic:
Auxiliary Clock Schematic (larger) &amp;hellip; which generates the following timing pulses &amp;hellip;
This post covers the last part of the puzzle which is designing the control logic that will take the pulses above and use them to drive the appropriate control lines at the right time according to the instruction the user requested as follows:
</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 2 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</link>
      <pubDate>Mon, 29 Jan 2018 22:12:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-2-of-3/</guid>
      <description>In my last post I made a start on the auxiliary control design which once completed will make it much easier to load instructions in to memory - effectively it&amp;rsquo;s a computer within a computer. If you haven&amp;rsquo;t read my previous post then it&amp;rsquo;s definitely worth doing so as this post picks up where that one left off. As a reminder though we&amp;rsquo;re looking to perform the following operations:
Auxiliary Control Operations Timing (larger) &amp;hellip; which can be derived from the following pulses &amp;hellip;
</description>
    </item>
    
    <item>
      <title>Auxiliary Control Design (Part 1 of 3)</title>
      <link>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</link>
      <pubDate>Wed, 24 Jan 2018 21:24:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2018/01/auxiliary-control-design-part-1-of-3/</guid>
      <description>My relay computer is now at the point where it can execute a program in memory without assistance. In order to do that though, of course, the program needs to be loaded into memory in the first place and at the moment that&amp;rsquo;s a bit of a pain. For each line of the program you need to set the primary data switches to match the desired &amp;lsquo;opcode&amp;rsquo;, gate the switches to the data bus, gate the program counter to the address bus, gate the data bus to the memory and then write to the memory - that&amp;rsquo;s four buttons to press simultaneously. Once that&amp;rsquo;s done the program counter needs advancing ready for the next line of the program via holding the select PC and load INC buttons followed by select INC and load PC. This cycle is repeated for each line of the program until it&amp;rsquo;s all loaded into memory. Like I said, it&amp;rsquo;s a pain and there must be a better way to do this.
</description>
    </item>
    
    <item>
      <title>Control Design: Fetch and Increment</title>
      <link>https://relaycomputer.co.uk/posts/2017/09/control-design-fetch-and-increment/</link>
      <pubDate>Sun, 17 Sep 2017 12:57:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/09/control-design-fetch-and-increment/</guid>
      <description>The design of the computer&amp;rsquo;s memory, incrementer and program counter are now complete but there&amp;rsquo;s one last piece of the &amp;lsquo;puzzle&amp;rsquo; required to get the computer running a program. The controller now needs updating to orchestrate the &amp;lsquo;fetch and increment&amp;rsquo; cycle. This cycle retrieves the next instruction from memory (into the instruction register) and then increments the program counter to point at the next instruction in memory. In this post I&amp;rsquo;ll cover the changes needed to the controller cards to implement this cycle.
</description>
    </item>
    
    <item>
      <title>Memory Design (Part 2 of 2)</title>
      <link>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-2-of-2/</link>
      <pubDate>Wed, 06 Sep 2017 22:55:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-2-of-2/</guid>
      <description>In my last post I started the design for the computer&amp;rsquo;s memory unit which is spread over two cards. With the lower memory card design in place its now time to finish the job and design the upper card which will interface the rest of the computer with the memory chip of the lower card.
Let&amp;rsquo;s dive straight in by bringing up the board interconnects from the lower card:
Memory Card A with initial interconnects (larger) The left two columns bring up the address bus for the memory chip which needs to be at 5V for a logic 1 and at ground for a logic 0. The third column brings up the outbound data bus which will sink 12V to ground for a logic 1 but holds at 12V for a logic 0 (effectively an inverse of what you&amp;rsquo;d expect). The fourth column brings up the inbound data bus which takes 5V for 1 and ground for 0 along with the write enable (WE) control line and output enable (OE) line which work in reverse (5V for disabled and ground for enabled). The last three connects to the right are power at 12V, ground for 5V and finally 5V. As you can probably guess there&amp;rsquo;s going to need to be quite a lot of &amp;rsquo;translation&amp;rsquo; logic on this card.
</description>
    </item>
    
    <item>
      <title>Memory Design (Part 1 of 2)</title>
      <link>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-1-of-2/</link>
      <pubDate>Sun, 03 Sep 2017 22:35:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/09/memory-design-part-1-of-2/</guid>
      <description>In my last post I explained my decision to use a &amp;lsquo;modern&amp;rsquo; memory chip in my relay computer &amp;hellip; I also alluded to there being some complexities in interfacing the rest of the computer with that memory chip. The memory unit will be spread over two cards and in this post I cover the design of the first half and expand on those &amp;lsquo;complexities&amp;rsquo; a bit.
The memory chip I&amp;rsquo;m using is from the &amp;lsquo;62&amp;rsquo; family of CMOS 256Kbit (32K x 8) Static RAM &amp;hellip; effectively meaning it can store 32,768 separate 8 bit values referenced by a 15bit address bus. Buying chips can be a bit of a &amp;rsquo;needle in a haystack&amp;rsquo; when you&amp;rsquo;re buying through one of the larger electronics suppliers (I use Mouser). Knowing the chip number isn&amp;rsquo;t enough to actually buy one and doing a search on Mouser for &amp;lsquo;62256 memory&amp;rsquo; narrows it down to 61 matches. I can narrow it down further as I know I need through-hole mounting (not surface mount) and that gets me to 6 matches. Next choice is access speed &amp;hellip; 55ns or 70ns. This is actually a bit of a mute point for this computer as it&amp;rsquo;ll get nowhere near that speed (the relays take around 5ms to switch) so lets ignore that one. So faced with 6 choices it comes down to price and what&amp;rsquo;s in stock. In the end I went for a mid-priced chip from Cypress Semiconductor &amp;hellip; a CY62256NLL-70PXC for £2.77 (&amp;lsquo;cheap as chips&amp;rsquo; &amp;hellip; literally).
</description>
    </item>
    
    <item>
      <title>The problem with memory</title>
      <link>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</link>
      <pubDate>Fri, 18 Aug 2017 22:58:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/08/the-problem-with-memory/</guid>
      <description>It&amp;rsquo;s time, at last, to start looking at the design for the computer&amp;rsquo;s memory and this is a bit of a game changer as it&amp;rsquo;s the final part of the jigsaw that lets the computer run a program. However, it&amp;rsquo;s also the part of the computer that leaves me in a bit of a quandary.
The problem with memory is that typically you need quite a lot of it and that&amp;rsquo;s something that doesn&amp;rsquo;t come easy with relays. In a way the registers already present in the computer are a kind of memory &amp;hellip; they store a single byte of data. So, effectively you can get two bytes worth of storage on one of the usual computer cards. You can maybe see where this is going.
</description>
    </item>
    
    <item>
      <title>Incrementer Design</title>
      <link>https://relaycomputer.co.uk/posts/2017/07/incrementer-design/</link>
      <pubDate>Mon, 17 Jul 2017 21:34:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/07/incrementer-design/</guid>
      <description>In my last post I covered the design of the 16-bit half adder which takes whatever value is currently on the address bus and increments it by one. To make this incremented value useable we need to create a register so that we can store the value ready for pushing back on to the address bus. Typically this incremented value would then be loaded into the program counter to get it ready for the next instruction in memory.
</description>
    </item>
    
    <item>
      <title>Incrementer Design: 16-bit Half Adder</title>
      <link>https://relaycomputer.co.uk/posts/2017/07/incrementer-design-16-bit-half-adder/</link>
      <pubDate>Sat, 15 Jul 2017 14:57:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/07/incrementer-design-16-bit-half-adder/</guid>
      <description>In the last post I introduced the design for the 1-bit Half Adder. This post covers connecting sixteen of these units together to make the 16-bit Half Adder.
So, diving straight in, here is what sixteen of the 1-bit Half Adder units look like all together on the usual 55 x 40 hole pad board:
16 x 1-bit Half Adder Units (larger) Each half adder bit is made up of two relays (as seen in the previous blog post) and starting at the bottom right of the diagram above the bit stages run upwards from 0 to 3 and then continuing on in rising columns to the left until bit 15 at the top left. Between each bit the carry out lines of the prior bit are connected to the carry in and the carry out lines connect to the carry in of the next bit effectively chaining each bit together to form a ripple carry adder circuit.
</description>
    </item>
    
    <item>
      <title>Incrementer Design: 1-bit Half Adder</title>
      <link>https://relaycomputer.co.uk/posts/2017/06/incrementer-design-1-bit-half-adder/</link>
      <pubDate>Sun, 04 Jun 2017 22:42:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/06/incrementer-design-1-bit-half-adder/</guid>
      <description>Typical isn&amp;rsquo;t it?! &amp;hellip; you wait 10 months for a post and then two come along at once. Well, all being well, this should be the first of a short flurry of posts as I move on to the design of the incrementer.
The incrementer takes any value currently on the 16-bit address bus and adds one to it, or rather, it increments it (clue is in the name of course). Typically that value on the address bus is going to come from the program counter (in order to point it at the next instruction in memory) but it&amp;rsquo;ll also be possible to bump the upcoming XY register eventually too.
</description>
    </item>
    
    <item>
      <title>Register Design: Program Counter</title>
      <link>https://relaycomputer.co.uk/posts/2017/05/register-design-program-counter/</link>
      <pubDate>Mon, 29 May 2017 17:13:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2017/05/register-design-program-counter/</guid>
      <description>It&amp;rsquo;s been a while since my last post &amp;hellip; pretty much 10 months in fact &amp;hellip; and I&amp;rsquo;d love to say I&amp;rsquo;ve been quietly working on my relay computer in the meantime but I haven&amp;rsquo;t. Designing, building and blogging about the various parts of the computer is really time consuming and unfortunately I&amp;rsquo;m just one of those people who has way too many hobbies. Anyway, after picking up some subscribers on YouTube I thought it was high time (or maybe I felt guilty enough) to focus back on the computer and get it through to the next milestone &amp;hellip; where it can step through a simple program stored in its memory without any human intervention (beyond entering the program itself and setting the computer running).
</description>
    </item>
    
    <item>
      <title>User Interface Design: Instruction, Clock and Sequencer</title>
      <link>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</link>
      <pubDate>Wed, 08 Apr 2015 23:19:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/04/user-interface-design-instruction-clock/</guid>
      <description>Over my last seven posts I&amp;rsquo;ve been slowly putting together the card designs so that the computer will be able to operate the MOV-8, ALU and SETAB instructions. The final step in this series is to update the designs for the two display cards along with the main switches to work with the new cards added recently.
Diving straight in here is the latest version of the Display A design:
</description>
    </item>
    
    <item>
      <title>Control Design: MOV-8, ALU and SETAB (part 2 of 2)</title>
      <link>https://relaycomputer.co.uk/posts/2015/04/control-design-mov-8-alu-and-setab-part/</link>
      <pubDate>Sat, 04 Apr 2015 08:06:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/04/control-design-mov-8-alu-and-setab-part/</guid>
      <description>In part one of this two part post I introduced the design of the control relays for each of the MOV-8, ALU and SETAB instructions. With these in hand I can now move on to placing these on the control cards and wire everything together. That&amp;rsquo;s &amp;lsquo;cards&amp;rsquo; rather than &amp;lsquo;card&amp;rsquo; as the control relays will be spread over two cards just like the sequencer relays are. This is partly because there&amp;rsquo;s more relays than would fit on a single card but mainly because access to a wider range of busses is needed.
</description>
    </item>
    
    <item>
      <title>Control Design: MOV-8, ALU and SETAB (part 1 of 2)</title>
      <link>https://relaycomputer.co.uk/posts/2015/03/control-design-mov-8-alu-and-setab-part/</link>
      <pubDate>Tue, 31 Mar 2015 22:26:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/03/control-design-mov-8-alu-and-setab-part/</guid>
      <description>Over the last five posts I&amp;rsquo;ve been building up the design of a set of cards so that the computer will be able to understand and perform the MOV-8, ALU and SETAB instructions. In this post I&amp;rsquo;m putting together the final piece of the jigsaw &amp;hellip; the control card. This will take the instruction class from the decoder (which derives its result from the instruction register) along with the pulses generated by the sequencer to operate the various control lines of the computer as required.
</description>
    </item>
    
    <item>
      <title>Pulse Distribution Design: Pulses C,D and E</title>
      <link>https://relaycomputer.co.uk/posts/2015/03/pulse-distribution-design-pulses-cd-and/</link>
      <pubDate>Sun, 22 Mar 2015 13:58:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/03/pulse-distribution-design-pulses-cd-and/</guid>
      <description>In my last post I covered the design of the 8-cycle finite state machine (FSM). In this post I&amp;rsquo;ll now take the outputs from that FSM and combine them to produce the timing pulses that will be needed to perform the MOV-8, ALU and SETAB instructions. The sequencer and pulse distribution share a &amp;lsquo;double&amp;rsquo; card and so I&amp;rsquo;ll also cover the resulting design when these two systems are combined.
To quickly recap &amp;hellip; the 8-cycle FSM will produce the following states given a clock signal as an input:
</description>
    </item>
    
    <item>
      <title>Sequencer Design: 8-cycle FSM</title>
      <link>https://relaycomputer.co.uk/posts/2015/01/sequencer-design-8-cycle-fsm/</link>
      <pubDate>Mon, 26 Jan 2015 22:03:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/01/sequencer-design-8-cycle-fsm/</guid>
      <description>So far I&amp;rsquo;ve got the design complete for the instruction register along with the initial design for the decoder and so I&amp;rsquo;m well on the way to having the computer perform MOV-8, ALU and SETAB instructions. Later I&amp;rsquo;ll get on to the control card design where the computer will operate the control lines according to the 8-bit opcode stored in the instruction register. Before that though there&amp;rsquo;s the sequencer card which will generate the pulses that drive the control card.
</description>
    </item>
    
    <item>
      <title>Decoder Design: MOV-8, ALU &amp; SETAB </title>
      <link>https://relaycomputer.co.uk/posts/2015/01/decoder-design-mov-8-alu-setab/</link>
      <pubDate>Sun, 04 Jan 2015 22:12:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2015/01/decoder-design-mov-8-alu-setab/</guid>
      <description>In my last post I introduced the design for the instruction register which holds the current 8-bit opcode that the computer is executing. The next card to design is the decoder which will take the 8-bit opcode and set either the MOV-8, ALU or SETAB control lines depending which class of instruction the opcode represents. This is actually quite straightforward and just needs a few relays to handle the logic.
</description>
    </item>
    
    <item>
      <title>Register Design: Instruction Register</title>
      <link>https://relaycomputer.co.uk/posts/2014/12/register-design-instruction-register/</link>
      <pubDate>Mon, 01 Dec 2014 21:00:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/12/register-design-instruction-register/</guid>
      <description>Well, it&amp;rsquo;s fair to say that I rather underestimated just how much time decorating the new house would take up &amp;hellip; and that&amp;rsquo;s mainly because &amp;lsquo;decorating&amp;rsquo; included re-wiring, re-plumbing, re-plastering, re-carpeting &amp;hellip; all before I got anywhere near choosing a tasteful shade of emulsion for the walls. Needless to say then that spending time on my relay computer has suffered quite a bit. However, things are starting to calm down (now that there&amp;rsquo;s two rooms in the house that are semi-habitable) so I can get back to designing the next bits for the computer.
</description>
    </item>
    
    <item>
      <title>Sequencing &amp; Control Design: Overview</title>
      <link>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</link>
      <pubDate>Fri, 19 Sep 2014 23:27:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/09/sequencing-control-design-overview/</guid>
      <description>I&amp;rsquo;ve now got my computer to a state where I can perform ALU operations and push values around the four registers by manually operating the various control lines. It&amp;rsquo;s time to move things on a bit now and work towards getting the computer to the point where given a specific instruction/op-code it can operate the control lines itself without further input from the user. Eventually the computer will be given a list of instructions to perform which it&amp;rsquo;ll work through step by step but for now the next milestone is to automate the operation of a single instruction.
</description>
    </item>
    
    <item>
      <title>User Interface: Display B Initial Design and Construction</title>
      <link>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-b-initial-design/</link>
      <pubDate>Sun, 20 Jul 2014 10:05:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-b-initial-design/</guid>
      <description>In my last post I put together the beginnings of the first display card &amp;hellip; named in a brilliant flash of nomenclature as display card A. This time I&amp;rsquo;m turning my attention to the second display card &amp;hellip; named (can you guess) display card B.
Whereas display A is dual purpose allowing a user to view and initiate control signals the second display card is read-only and displays the primary state of the computer. Initially this &amp;lsquo;primary state&amp;rsquo; comprises of the data bus contents, condition register status and ALU function code / operation. I also had a rectangular gap spare on the card that looked like it&amp;rsquo;d fit an ammeter so that also now forms part of the second display too.
</description>
    </item>
    
    <item>
      <title>User Interface: Display A Initial Design and Construction</title>
      <link>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-initial-design/</link>
      <pubDate>Sat, 12 Jul 2014 10:31:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-display-initial-design/</guid>
      <description>Following on from working on the main data switches in my last post this time I&amp;rsquo;ve taken the first steps in designing and constructing the first of two display cards which will sit in the upper enclosure. The first card (display A) has a dual purpose &amp;hellip; it provides a display to show which control signals are in operation between the various parts of the computer but also allows the operator to manually control those signals when the computer is set to a special &amp;lsquo;diagnostic&amp;rsquo; mode.
</description>
    </item>
    
    <item>
      <title>User Interface: Data Switches</title>
      <link>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</link>
      <pubDate>Sat, 05 Jul 2014 09:40:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/07/user-interface-data-switches/</guid>
      <description>Now I&amp;rsquo;ve got a fully working ALU and four registers completed I want to take a short break from card building and turn my attention to making it easier to interact with the computer. Currently I&amp;rsquo;m controlling the computer via a set of DIP switches which is incredibly fiddly so it&amp;rsquo;s time to construct something &amp;lsquo;chunkier&amp;rsquo;.
The switches I&amp;rsquo;m going to concentrate on first are the primary data switches which permit values to be placed on the data bus. These switches won&amp;rsquo;t be directly connected to the data however because as a user you&amp;rsquo;d have to keep turning them all off so the computer can use the bus &amp;hellip; instead I&amp;rsquo;ll build a gating circuit so the value on the switches can be placed on and off the bus as needed. Additionally the gating circuit will also allow the values on the switches to be gated over to the lower 8 bits of the 16 bit address bus. This will allow the quick setting of addresses once the computer gains its memory card and register. I was originally thinking of having a separate set of 16 switches for setting the address bus but decided in the end that I didn&amp;rsquo;t want to use the space up for something I didn&amp;rsquo;t think would get used that much. The upshot of this is that to set the upper 8 bits of the address bus requires gating the switches to the data bus and then loading the higher 8 bits on one of the 16 bit registers (like the upcoming M2, Y and J2 registers). That said, at the moment everything is manual until I build the data and address load circuitry so for now gating the switches on to the data bus would always be followed by a manual register load operation.
</description>
    </item>
    
    <item>
      <title>Register Design: B and C 8-bit Registers</title>
      <link>https://relaycomputer.co.uk/posts/2014/05/register-design-b-and-c-8-bit-registers/</link>
      <pubDate>Sun, 11 May 2014 10:08:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/05/register-design-b-and-c-8-bit-registers/</guid>
      <description>In a recent post I put up the design for the A and D 8-bit register card &amp;hellip; the B and C register card is very similar in design but has the additional complexity that it has to directly feed the ALU. In another recent post I covered how to take multiple outputs from a relay without risking back-feed by utilising diodes in the output line. This post therefore brings together those two designs and although it&amp;rsquo;s essentially a re-hashing of the AD card post but with extra bits I&amp;rsquo;ll go through the design as I did with the AD card so that this post stands alone as it were.
</description>
    </item>
    
    <item>
      <title>Register Design: Dual Output 8-bit Register</title>
      <link>https://relaycomputer.co.uk/posts/2014/04/register-design-dual-output-8-bit/</link>
      <pubDate>Thu, 24 Apr 2014 22:56:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/04/register-design-dual-output-8-bit/</guid>
      <description>In the last post I introduced the design for the A/D register card (which as its name suggests contains the A and D 8-bit registers). I&amp;rsquo;m now making a start on the design for the B/C register card and although its pretty much the same as the A/D card there&amp;rsquo;s an extra complexity because the B/C registers additionally feed the ALU B and C inputs.
For the A and D registers I ended up with the following circuit per 8-bit register:
</description>
    </item>
    
    <item>
      <title>Register Design: A and D 8-bit Registers</title>
      <link>https://relaycomputer.co.uk/posts/2014/04/register-design-and-d-8-bit-registers/</link>
      <pubDate>Sun, 20 Apr 2014 11:15:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/04/register-design-and-d-8-bit-registers/</guid>
      <description>In the last post I introduced the design for a general purpose 8-bit register. This post covers taking two of those registers along with status LEDs and gating relays to implement the full A and D registers.
So, diving straight in, here is what the main bit relays look like for the two 8-bit registers when placed on the usual 55 x 40 hole pad board (excluding wire links):
2 x 8 bit register relays (larger) Each of the relays above stores a single 1-bit value so there&amp;rsquo;s 16-bits worth in total (which could all be used together if we were making a 16-bit register) or two lots of 8-bits (for our two 8-bit registers). Each of the 1-bit register relays need gating to and from the data bus so that the values stored don&amp;rsquo;t conflict with any other value on the data bus. With these additional control and gating relays added we get the following (this time including internal wire links in the 1-bit register relays and result links between the 1-bit register relays and the gating relays):
</description>
    </item>
    
    <item>
      <title>Register Design: General Purpose 8-bit Register</title>
      <link>https://relaycomputer.co.uk/posts/2014/04/register-design-general-purpose-8-bit/</link>
      <pubDate>Wed, 16 Apr 2014 22:08:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/04/register-design-general-purpose-8-bit/</guid>
      <description>This post covers the design of a general purpose 8-bit register that can be loaded from the data bus and then selected back to the data bus at a later time. This permits temporary storage of 8-bit values whilst performing various operations, for example, ALU functions. This post goes back over some of the ground already covered by the design of the condition registers which are a slightly simplified version of the registers detailed here.
</description>
    </item>
    
    <item>
      <title>Enclosure Update: Laser Cutting</title>
      <link>https://relaycomputer.co.uk/posts/2014/04/enclosure-update-laser-cutting/</link>
      <pubDate>Thu, 10 Apr 2014 19:58:00 +0100</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/04/enclosure-update-laser-cutting/</guid>
      <description>I couldn&amp;rsquo;t resist it any longer &amp;hellip; I&amp;rsquo;ve ordered the laser cut parts for the case doors, sides and bay floor/ceilings. I did say I&amp;rsquo;d wait for my chosen laser cut website to put out a free delivery offer but I ended up crumbling under the weight of my own impatience. Needless to say within 24 hours of placing my order they announced a free delivery offer for the end of April &amp;hellip; c&amp;rsquo;est la vie and all that jazz.
</description>
    </item>
    
    <item>
      <title>Enclosure Disclosure</title>
      <link>https://relaycomputer.co.uk/posts/2014/03/enclosure-disclosure/</link>
      <pubDate>Sat, 01 Mar 2014 10:55:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/03/enclosure-disclosure/</guid>
      <description>Sorry, I will try to rain in the terrible punning post titles.
This time I wanted to share the thoughts and ideas I&amp;rsquo;ve been having around building a case to hold my computer when it&amp;rsquo;s eventually complete. I wanted to use a material that would be easy to handle and work with but also one that would produce a nice looking result. I was initially drawn to using wood or possibly even laser cut plywood but in the end I settled on aluminium profile as its sturdy, easy to assemble and, I think, looks really great. In addition to this it&amp;rsquo;s available in a large variety of sizes, shapes and there&amp;rsquo;s plenty of fixtures and fittings available for it.
</description>
    </item>
    
    <item>
      <title>Sketchy Diversion</title>
      <link>https://relaycomputer.co.uk/posts/2014/02/sketchy-diversion/</link>
      <pubDate>Tue, 04 Feb 2014 19:10:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2014/02/sketchy-diversion/</guid>
      <description>I&amp;rsquo;m taking a break &amp;hellip; just a short one.
In between all the bouts of wire wrapping for the ALU arithmetic card I&amp;rsquo;m starting to think about enclosure options for the computer when it&amp;rsquo;s finally (finally!) finished. I&amp;rsquo;ve been trawling the internet for inspiration and I&amp;rsquo;m starting to get a feel for the sort of materials and finish I want and I&amp;rsquo;ve even been getting some prototype laser etching done (more on this in a later post). One thing I&amp;rsquo;m finding as I&amp;rsquo;m going along though is that I&amp;rsquo;m trying to picture things in my head and there&amp;rsquo;s a lot of guesswork going on. What I need is to employ some CAD so I can make sure things fit together before really fitting them together.
</description>
    </item>
    
    <item>
      <title>Backplane Design and Construction</title>
      <link>https://relaycomputer.co.uk/posts/2013/12/backplane-design-and-construction/</link>
      <pubDate>Tue, 03 Dec 2013 19:27:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/12/backplane-design-and-construction/</guid>
      <description>Originally when I was thinking about how I&amp;rsquo;d connect up the various cards of this computer I had ribbon cables in mind. Ribbon cables are straightforward to use and physically flexible which would
allow me to work out how I&amp;rsquo;d physically arrange the cards later on. However, the more I thought about it the more I liked the idea of using a backplane that the cards would slot in to — a bit like those 19 inch server racks that take CPU cards. This would also give the cards some physical support so I could test several cards together with the whole thing freestanding.
</description>
    </item>
    
    <item>
      <title>ALU Design: Control Unit</title>
      <link>https://relaycomputer.co.uk/posts/2013/12/alu-design-control-unit/</link>
      <pubDate>Sun, 01 Dec 2013 21:21:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/12/alu-design-control-unit/</guid>
      <description>In the last three posts I introduced the design for the 3-to-8 Function Decoder, Zero Detect circuit and the Condition Registers. In this post I&amp;rsquo;ll put all three of these components together to make up the ALU Control Card. So, placing the relays from the three components onto the card (excluding wire links) we get the following:
ALU Control Card Relays (larger) Unlike the other cards that make up the full ALU (the logic and arithmetic cards) things aren&amp;rsquo;t quite so tightly packed in this time. Despite this I&amp;rsquo;ve pushed the relays out towards the edges of the card to leave room for any future ALU control expansion or modifications without requiring an extra card. I&amp;rsquo;ll be displaying the current state of the 3-to-8 Decoder and Condition Registers with LEDs along the front of the card as with the other cards designed so far. The LEDs are the same 12V ones as before (to save space that would be used by the additional resistors) and follow the same colour code of red for results, yellow for inputs and green for output control signals. Diagram wise the display looks like this:
</description>
    </item>
    
    <item>
      <title>ALU Design: Condition Registers</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/alu-design-condition-registers/</link>
      <pubDate>Sat, 30 Nov 2013 10:12:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/alu-design-condition-registers/</guid>
      <description>This post covers the design of the ALU Condition Registers which along with the 3-to-8 Function Decoder and Zero Detect circuit (both covered in my previous posts) make up the ALU Control Card. There are three Condition Registers in this computer:
Carry: set when a bit is carried in the Arithmetic Unit (which can also indicate arithmetic overflow depending on the interpretation of the numbers being added). Zero: set when the ALU result is zero (all bits are off). Sign: set when the most significant bit is set (which would indicate a negative result for signed values). This condition has no direct meaning for unsigned numbers (other than indicating the number has a value of 128 or more). When the ALU performs an operation the current values of these three conditions are stored in the condition registers so that they can be referred to in other operations. An example of this would be where given two numbers the first is negated and then added to the second &amp;hellip; if the two numbers are equal it will result in zero and therefore the Zero condition will be set. Based on this condition register being set you could then branch to a different location in the executing program if desired. That is, for example, if number A and B are equal then go to line C in the program. It&amp;rsquo;s this &amp;lsquo;branching&amp;rsquo; functionality that elevates the computer in terms of power and flexibility and the condition registers are at the heart of this.
</description>
    </item>
    
    <item>
      <title>ALU Design: Zero Detect</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/alu-design-zero-detect/</link>
      <pubDate>Sat, 23 Nov 2013 08:57:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/alu-design-zero-detect/</guid>
      <description>This post covers the design of the Zero Detect circuit which along with the 3-to-8 Function Decoder (covered in my last post) and the Condition Registers (next post) make up the ALU Control Card. The Zero Detect circuit &amp;hellip; wait for it &amp;hellip; detects when a value is zero. The value in question is taken from the data bus so in effect we&amp;rsquo;re detecting when no bits are set. The output from this circuit is then passed to the Condition Registers so that the current value can be stored for future operations. The circuit itself is nice and simple:
</description>
    </item>
    
    <item>
      <title>ALU Design: Function Decoder</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/design-function-decoder/</link>
      <pubDate>Wed, 20 Nov 2013 22:18:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/design-function-decoder/</guid>
      <description>This post covers the design of a 3-to-8 Function Decoder which along with the Zero Detect circuit and Condition Registers will all go in to the ALU Control Card. The Decoder takes a 3-bit ALU Function code as its input and activates 1 of 8 control lines accordingly. The function codes are as follows:
Code Operation Description 000 CLR Clear/No Operation 001 ADD B &#43; C 010 INC Increment B 011 AND B AND C 100 OR B OR C 101 XOR B XOR C 110 NOT NOT C 111 SHL Shift Left B The control lines which are fed to the Arithmetic and Logic Units via the Ctrl-Z bus are:
</description>
    </item>
    
    <item>
      <title>ALU Design: 8-bit Arithmetic Unit</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-arithmetic-unit/</link>
      <pubDate>Sun, 17 Nov 2013 10:43:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-arithmetic-unit/</guid>
      <description>In the last post I introduced the design for the 1-bit Arithmetic Unit. This post covers connecting eight of these units together to make an 8-bit Arithmetic Unit along with result gating and increment functionality.
So, diving straight in, here is what eight of the 1-bit Arithmetic Units look like all together on the usual 55 x 40 hole pad board (excluding wire lines):
8 x 1-bit Arithmetic Unit Relays (larger) As before (with the Logic Unit card) things are a bit on the tight side but everything fits within the 40 hole horizontal confines of the pad board (as if by magic). Each of the 1-bit Arithmetic Units produces a 1-bit output and these need gating back on to the data bus so that the result doesn&amp;rsquo;t conflict with any other Logic Unit output (or any future outputs from places like the Registers etc). With these additional relays added we get the following (this time including internal wire links in the 1-bit Arithmetic Units and result links between the Arithmetic Units and the gating relays):
</description>
    </item>
    
    <item>
      <title>ALU Design: 1-bit Arithmetic Unit</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-arithmetic-unit/</link>
      <pubDate>Fri, 15 Nov 2013 22:33:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-arithmetic-unit/</guid>
      <description>This post covers the design of a 1-bit Arithmetic Unit that can add two input bits together (B and C) with carry in and out. Here&amp;rsquo;s a schematic of the 1-bit Arithmetic Unit (based directly on the one used in the Harry Porter Relay Computer):
The diagram shows two 4PDT relays (just as before for the 1-bit Logic Unit) but this time the second relay has been rotated 180 degrees to make the diagram simpler to draw. B and C are the two 1-bit inputs that drive the relay coils, V is a permanent connection to the power supply and R is the resulting bit. CI is the carry in signal along with its inverted partner ~CI. Similarly CO is the carry output and ~CO is its inverted partner. It&amp;rsquo;s the use of these regular and inverted carry signals that makes this design so neat &amp;hellip; and actually this isn&amp;rsquo;t one of Harry&amp;rsquo;s &amp;hellip; this design goes back a lot further.
</description>
    </item>
    
    <item>
      <title>ALU Design: 8-bit Logic Unit</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-logic-unit/</link>
      <pubDate>Wed, 13 Nov 2013 22:42:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/design-8-bit-logic-unit/</guid>
      <description>In the last post I introduced the design for a 1-bit Logic Unit. This post covers the design effort to cram 8 of these on to a single pad board complete with connectors, status LEDs and gating relays thereby forming a complete 8-bit Logic Unit.
Sticking with the same diagram style I introduced in the last post here is what 8 of the 1-bit Logic Units look like all crammed on to the 55 x 40 hole pad board (excluding wire links):
</description>
    </item>
    
    <item>
      <title>ALU Design: 1-bit Logic Unit</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-logic-unit/</link>
      <pubDate>Mon, 11 Nov 2013 23:32:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/design-1-bit-logic-unit/</guid>
      <description>This post covers the design of a 1-bit Logic Unit that can produce AND, OR, XOR, NOT and SHL (Shift Left) outputs from two input bits B and C. Here&amp;rsquo;s a schematic of the 1-bit Logic Unit (based directly on the one used in the Harry Porter Relay Computer):
The diagram shows two 4PDT (4 pole double toggle) relays with the coils of each shown as a striped box at the top. The four double toggle switches are also shown on each relay and the current position of each switch is as when the relay is off. When power is applied to the relay coil all four switches change over simultaneously. The two relays together with all the various connections form the 1-bit Logic Unit. Inputs to the unit are shown with &amp;lsquo;cupped&amp;rsquo; line ends: B and C are the two 1-bit inputs; V is a permanent connection to the power supply. Outputs from the unit are shown with an arrowed line end: the outputs AND, OR, XOR, NOT and SHL. Wire joins are shown with a dot (otherwise the wire is passing over but not connecting to another wire) and unused switches on a relay are shown in grey.
</description>
    </item>
    
    <item>
      <title>Relay Rumination</title>
      <link>https://relaycomputer.co.uk/posts/2013/11/relay-rumination/</link>
      <pubDate>Sun, 10 Nov 2013 23:16:00 +0000</pubDate>
      
      <guid>https://relaycomputer.co.uk/posts/2013/11/relay-rumination/</guid>
      <description>If there&amp;rsquo;s one thing a relay computer needs a lot of it&amp;rsquo;s &amp;hellip; erm &amp;hellip; relays (of course) &amp;hellip; which happens to be a bit unfortunate as relays, compared to the other parts of the computer, are rather expensive. The Dr Harry Porter Relay Computer (which my computer is based on) uses 415 x 4PDT (4 pole double toggle) relays in total. A comparable part is the Omron MY4-DC12(S) relay and a quick check online with Mouser (other suppliers are available ;) prices them around £3.20 a piece (excluding UK VAT @ 20%) &amp;hellip; that&amp;rsquo;s just under £1600 including VAT which is a bit eye watering for a hobby project (the Harry Porter computer came to just over $5000 in total for everything). Also of note is that the MY4 relays are sized 28 x 21.5 x 36mm &amp;hellip; not huge but big enough when you&amp;rsquo;ve got 415 of them wired together (again, see the Harry Porter computer to see exactly how big these machines can be). Here&amp;rsquo;s a scaled diagram of the MY4 relay showing the coil and four sets of double toggle contacts.
</description>
    </item>
    
  </channel>
</rss>
